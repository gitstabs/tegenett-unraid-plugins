<?xml version='1.0' standalone='yes'?>
<!DOCTYPE PLUGIN [
<!ENTITY name      "atp_backup">
<!ENTITY author    "Tegenett">
<!ENTITY version   "2026.01.30g">
<!ENTITY launch    "Settings/AtpBackup">
<!ENTITY pluginURL "https://raw.githubusercontent.com/gitstabs/tegenett-unraid-plugins/main/atp_backup/atp_backup.plg">
]>

<PLUGIN name="&name;" author="&author;" version="&version;" launch="&launch;" pluginURL="&pluginURL;" icon="shield" min="7.0.0" support="https://github.com/gitstabs/tegenett-unraid-plugins/issues">

<CHANGES>
##2026.01.30g
- FIX: Dashboard cards (Upcoming Jobs, Recent Activity) now stack vertically on tablet/mobile
- FIX: Improved responsive layout for smaller screens

##2026.01.30f
- FIX: Recent Activity table scrollbar now stays within card on mobile/tablet

##2026.01.30e
- FIX: ENTITY name restored to snake_case (atp_backup) for Unraid plugin ID

##2026.01.30d
- BUILD: Rebuild with fixed build system

##2026.01.30c
- FIX: Removed HTML tags from shared CSS/JS comments that broke page rendering

##2026.01.30b
- BUILD: Converted to src-file structure for automatic GitHub builds
- BUILD: Shared CSS/JS now injected automatically from shared/ folder

##2026.01.30a
- BUILD: Shared CSS/JS now injected automatically from shared/ folder
- BUILD: CSS variable aliases for backwards compatibility (--tb-* maps to --atp-*)

##2026.01.30
- SECURITY: Added CSRF token validation for all modifying AJAX requests
- SECURITY: Improved exception handling with specific exception types
- CODE: PHP handler now validates Unraid 7.x CSRF tokens

##2026.01.29d
- UI: Tab buttons margin/font reset for consistent spacing (reversion bump)

##2026.01.29c
- UI: Version moved to far right (consistent with ATP Emby Smart Cache)
- UI: Tab buttons reset margin for consistent gap spacing

##2026.01.29b
- UI: New tab styling (full button highlight instead of underline)
- UI: Improved mobile responsiveness for all tables
- UI: Better table headers with uppercase styling

##2026.01.29a
- RENAME: Plugin renamed from tegenett_backup to atp_backup (A Tegenett Plugin)
- All paths updated: config, data, logs now use atp_backup prefix
- NOTE: Requires fresh install - see migration guide

##2026.01.28k
- NEW: Reset Database - clear history, reset statistics, or full reset
- NEW: Exclude Patterns UI - quick-add presets (temp, logs, cache, OS junk, docker)
- NEW: Pre/Post Backup Scripts - run custom scripts before and after backups
- NEW: Backup Health Dashboard - visual overview of job health status
- NEW: Log Rotation - automatic rotation with configurable size and count
- FIX: Database schema v3 for pre/post scripts

##2026.01.28j
- FIX: Speed now shows in appropriate units (B/s, KB/s, MB/s)
- FIX: Size and speed formatting in Discord notifications
- FIX: Improved auto-start with delayed background start

##2026.01.28i
- FIX: Rsync stats parsing

##2026.01.28h
- FIX: Service auto-starts via /boot/config/go

##2026.01.28
- CSRF token support for Unraid 7

##2026.01.27
- Initial release
</CHANGES>

<!-- Pre-install: Stop existing service and clean up -->
<FILE Run="/bin/bash">
<INLINE>
<![CDATA[
#!/bin/bash
PLUGIN_NAME="atp_backup"
PLUGIN_DIR="/usr/local/emhttp/plugins/${PLUGIN_NAME}"
LOG="/var/log/${PLUGIN_NAME}_install.log"

echo "$(date): Pre-install starting" >> "$LOG"

# Stop old service if running
if [ -f "/var/run/${PLUGIN_NAME}.pid" ]; then
    PID=$(cat /var/run/${PLUGIN_NAME}.pid)
    echo "$(date): Stopping service PID $PID" >> "$LOG"
    kill "$PID" 2>/dev/null
    sleep 3
fi
pkill -f "${PLUGIN_NAME}.py" 2>/dev/null || true

rm -rf "${PLUGIN_DIR}"
mkdir -p "${PLUGIN_DIR}/include"

echo "$(date): Pre-install complete" >> "$LOG"
]]>
</INLINE>
</FILE>

<!-- Main Page File -->
<FILE Name="/usr/local/emhttp/plugins/atp_backup/AtpBackup.page">
<INLINE>
<![CDATA[
Menu="Utilities"
Title="ATP Backup"
Icon="shield"
---
<?php
$plugin = "atp_backup";
$version = "v2026.01.30g";
$docroot = $docroot ?? $_SERVER['DOCUMENT_ROOT'] ?: '/usr/local/emhttp';
$pluginDir = "{$docroot}/plugins/{$plugin}";

// Check if service is running
$pidFile = "/var/run/{$plugin}.pid";
$isRunning = false;
$pid = null;
if (file_exists($pidFile)) {
    $pid = trim(file_get_contents($pidFile));
    if ($pid && file_exists("/proc/{$pid}")) {
        $isRunning = true;
    } else {
        $pid = null;
    }
}
?>

<script>var csrf_token = "<?=$var['csrf_token']?>";</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<style>

/* ============================================
   ATP SHARED CSS - Injected by build.py
   ============================================ */
/* ============================================
   ATP COMMON CSS - v2026.01.30
   Shared styles for all ATP (A Tegenett Plugin) plugins
   Injected automatically by build.py
   ============================================ */

/* ============================================
   CSS VARIABLES (Theme Colors)
   ============================================ */
:root {
    /* Brand Colors - ATP Orange Theme */
    --atp-primary: #e67e22;
    --atp-primary-dark: #d35400;
    --atp-primary-light: #f39c12;

    /* Status Colors */
    --atp-success: #27ae60;
    --atp-success-dark: #1e8449;
    --atp-danger: #c0392b;
    --atp-danger-dark: #a93226;
    --atp-warning: #f39c12;
    --atp-warning-dark: #d68910;
    --atp-info: #3498db;
    --atp-info-dark: #2980b9;

    /* Theme-aware colors (from Unraid CSS variables) */
    --atp-bg: var(--body-background, #1a1a1a);
    --atp-card-bg: var(--card-background, #262626);
    --atp-text: var(--text-color, #e0e0e0);
    --atp-text-muted: var(--text-muted, #888);
    --atp-border: var(--border-color, #3a3a3a);

    /* Spacing */
    --atp-spacing-xs: 5px;
    --atp-spacing-sm: 10px;
    --atp-spacing-md: 15px;
    --atp-spacing-lg: 20px;
    --atp-spacing-xl: 30px;

    /* Border Radius */
    --atp-radius-sm: 4px;
    --atp-radius-md: 8px;
    --atp-radius-lg: 12px;
    --atp-radius-round: 50%;
}

/* ============================================
   LAYOUT - Container
   ============================================ */
.atp-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: var(--atp-spacing-lg);
}

/* ============================================
   HEADER
   ============================================ */
.atp-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--atp-spacing-lg);
    padding-bottom: var(--atp-spacing-md);
    border-bottom: 1px solid var(--atp-border);
}

.atp-title {
    display: flex;
    align-items: center;
    gap: var(--atp-spacing-md);
}

.atp-title h1 {
    margin: 0;
    color: var(--atp-primary);
    font-size: 1.8em;
}

.atp-title h1 i {
    margin-right: var(--atp-spacing-sm);
}

.atp-header-right {
    display: flex;
    gap: var(--atp-spacing-sm);
    align-items: center;
}

.atp-version {
    color: var(--atp-text-muted);
    font-size: 0.85em;
}

/* Status Badge */
.atp-status-badge {
    padding: 0 16px;
    border-radius: var(--atp-radius-sm);
    font-size: 0.85em;
    font-weight: 600;
    white-space: nowrap;
    height: 36px;
    line-height: 36px;
    display: inline-block;
}

.atp-status-badge i {
    font-size: 0.6em;
    margin-right: 6px;
}

.atp-status-badge.running { background: var(--atp-success); color: white; }
.atp-status-badge.stopped { background: var(--atp-danger); color: white; }
.atp-status-badge.warning { background: var(--atp-warning); color: white; }

/* ============================================
   TABS - Navigation
   ============================================ */
.atp-tabs {
    display: flex;
    gap: 5px;
    margin-bottom: var(--atp-spacing-lg);
    border-bottom: 1px solid var(--atp-border);
    padding-bottom: var(--atp-spacing-sm);
    flex-wrap: wrap;
}

.atp-tab {
    padding: 10px 20px;
    background: var(--atp-card-bg);
    border: 1px solid var(--atp-border);
    border-radius: var(--atp-radius-sm) var(--atp-radius-sm) 0 0;
    color: var(--atp-text-muted);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
}

.atp-tab:hover {
    background: rgba(255, 255, 255, 0.05);
    color: var(--atp-text);
}

.atp-tab.active {
    background: var(--atp-primary);
    color: #fff;
    border-color: var(--atp-primary);
}

.atp-tab i {
    margin-right: 8px;
}

/* Panels */
.atp-panel { display: none; }
.atp-panel.active { display: block; }

/* ============================================
   CARDS
   ============================================ */
.atp-card {
    background: var(--atp-card-bg);
    border-radius: var(--atp-radius-md);
    padding: var(--atp-spacing-lg);
    margin-bottom: var(--atp-spacing-lg);
    border: 1px solid var(--atp-border);
}

.atp-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--atp-spacing-md);
    padding-bottom: var(--atp-spacing-sm);
    border-bottom: 1px solid var(--atp-border);
}

.atp-card-title {
    margin: 0;
    font-size: 1.1em;
    color: var(--atp-primary);
}

.atp-card-title i {
    margin-right: 8px;
}

/* Section (alternative card style) */
.atp-section {
    background: var(--atp-card-bg);
    border: 1px solid var(--atp-border);
    border-radius: var(--atp-radius-md);
    padding: var(--atp-spacing-lg);
    margin-bottom: var(--atp-spacing-lg);
}

.atp-section-title {
    color: var(--atp-primary);
    font-size: 14px;
    font-weight: bold;
    text-transform: uppercase;
    margin-bottom: var(--atp-spacing-md);
    padding-bottom: var(--atp-spacing-sm);
    border-bottom: 1px solid var(--atp-border);
}

.atp-section-title i {
    margin-right: 8px;
}

/* ============================================
   STAT CARDS (Dashboard)
   ============================================ */
.atp-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--atp-spacing-md);
    margin-bottom: var(--atp-spacing-lg);
}

.atp-stat-card {
    background: var(--atp-card-bg);
    border-radius: var(--atp-radius-md);
    padding: var(--atp-spacing-lg);
    border: 1px solid var(--atp-border);
    text-align: center;
}

.atp-stat-icon {
    font-size: 2em;
    margin-bottom: var(--atp-spacing-sm);
    color: var(--atp-primary);
}

.atp-stat-value {
    font-size: 1.8em;
    font-weight: bold;
    color: var(--atp-text);
}

.atp-stat-label {
    color: var(--atp-text-muted);
    font-size: 0.9em;
    margin-top: var(--atp-spacing-xs);
}

/* ============================================
   BUTTONS
   ============================================ */
.atp-btn {
    padding: 8px 16px;
    border: none;
    border-radius: var(--atp-radius-sm);
    cursor: pointer;
    font-size: 0.9em;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s;
    text-decoration: none;
}

.atp-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.atp-btn-primary { background: var(--atp-primary); color: white; }
.atp-btn-primary:hover:not(:disabled) { background: var(--atp-primary-dark); }

.atp-btn-success { background: var(--atp-success); color: white; }
.atp-btn-success:hover:not(:disabled) { background: var(--atp-success-dark); }

.atp-btn-danger { background: var(--atp-danger); color: white; }
.atp-btn-danger:hover:not(:disabled) { background: var(--atp-danger-dark); }

.atp-btn-warning { background: var(--atp-warning); color: white; }
.atp-btn-warning:hover:not(:disabled) { background: var(--atp-warning-dark); }

.atp-btn-info { background: var(--atp-info); color: white; }
.atp-btn-info:hover:not(:disabled) { background: var(--atp-info-dark); }

.atp-btn-secondary { background: var(--atp-border); color: var(--atp-text); }
.atp-btn-secondary:hover:not(:disabled) { background: rgba(255, 255, 255, 0.1); }

.atp-btn-sm { padding: 5px 10px; font-size: 0.85em; }
.atp-btn-lg { padding: 12px 24px; font-size: 1em; }

/* ============================================
   TABLES
   ============================================ */
.atp-table-wrapper {
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    margin-bottom: var(--atp-spacing-md);
}

.atp-table {
    width: 100%;
    border-collapse: collapse;
    min-width: 600px;
}

.atp-table th,
.atp-table td {
    padding: 12px;
    text-align: left;
    border-bottom: 1px solid var(--atp-border);
}

.atp-table th {
    color: var(--atp-primary);
    font-weight: 600;
    font-size: 11px;
    text-transform: uppercase;
    white-space: nowrap;
    background: rgba(0, 0, 0, 0.2);
}

.atp-table tr:hover {
    background: rgba(255, 255, 255, 0.02);
}

.atp-table .filename,
.atp-table .truncate {
    max-width: 200px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* ============================================
   FORMS
   ============================================ */
.atp-form-group {
    margin-bottom: var(--atp-spacing-md);
}

.atp-form-group label {
    display: block;
    margin-bottom: var(--atp-spacing-xs);
    color: var(--atp-text);
    font-weight: 500;
}

.atp-form-group input,
.atp-form-group select,
.atp-form-group textarea {
    width: 100%;
    padding: 10px;
    border: 1px solid var(--atp-border);
    border-radius: var(--atp-radius-sm);
    background: var(--atp-bg);
    color: var(--atp-text);
    font-size: 0.95em;
}

.atp-form-group input:focus,
.atp-form-group select:focus,
.atp-form-group textarea:focus {
    outline: none;
    border-color: var(--atp-primary);
}

.atp-form-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--atp-spacing-md);
}

.atp-form-hint {
    font-size: 0.85em;
    color: var(--atp-text-muted);
    margin-top: 4px;
}

/* Checkbox styling */
.atp-checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
}

.atp-checkbox-label input[type="checkbox"] {
    width: auto;
    margin: 0;
}

/* ============================================
   BADGES
   ============================================ */
.atp-badge {
    display: inline-block;
    padding: 3px 10px;
    border-radius: var(--atp-radius-lg);
    font-size: 0.8em;
    font-weight: 600;
}

.atp-badge-success { background: rgba(39, 174, 96, 0.2); color: #27ae60; }
.atp-badge-danger { background: rgba(192, 57, 43, 0.2); color: #e74c3c; }
.atp-badge-warning { background: rgba(243, 156, 18, 0.2); color: #f39c12; }
.atp-badge-info { background: rgba(52, 152, 219, 0.2); color: #3498db; }

/* ============================================
   STATUS TEXT COLORS
   ============================================ */
.atp-text-success, .success { color: var(--atp-success) !important; }
.atp-text-danger, .danger { color: var(--atp-danger) !important; }
.atp-text-warning, .warning { color: var(--atp-warning) !important; }
.atp-text-info, .info { color: var(--atp-info) !important; }
.atp-text-muted { color: var(--atp-text-muted) !important; }

/* ============================================
   LOG VIEWER
   ============================================ */
.atp-log-viewer {
    background: #1a1a1a;
    border: 1px solid var(--atp-border);
    border-radius: var(--atp-radius-sm);
    padding: var(--atp-spacing-md);
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    font-size: 0.85em;
    line-height: 1.5;
    max-height: 500px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-all;
    color: #0f0;
}

/* ============================================
   PROGRESS BAR
   ============================================ */
.atp-progress-bar {
    height: 8px;
    background: #333;
    border-radius: var(--atp-radius-sm);
    overflow: hidden;
    flex-grow: 1;
    min-width: 100px;
}

.atp-progress-fill {
    height: 100%;
    background: var(--atp-success);
    transition: width 0.3s, background 0.3s;
}

.atp-progress-fill.warning { background: var(--atp-warning); }
.atp-progress-fill.danger { background: var(--atp-danger); }

/* ============================================
   TOOLBAR
   ============================================ */
.atp-toolbar {
    display: flex;
    gap: var(--atp-spacing-sm);
    margin-bottom: var(--atp-spacing-md);
    align-items: center;
    flex-wrap: wrap;
}

/* ============================================
   ACTIVITY LIST
   ============================================ */
.atp-activity {
    max-height: 300px;
    overflow-y: auto;
}

.atp-activity-item {
    padding: var(--atp-spacing-sm);
    border-bottom: 1px solid var(--atp-border);
    display: flex;
    align-items: center;
    gap: var(--atp-spacing-sm);
}

.atp-activity-item:last-child {
    border-bottom: none;
}

.atp-activity-icon {
    width: 32px;
    height: 32px;
    border-radius: var(--atp-radius-round);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    flex-shrink: 0;
}

.atp-activity-icon.copy { background: var(--atp-info); }
.atp-activity-icon.cleanup { background: var(--atp-warning); }
.atp-activity-icon.error { background: var(--atp-danger); }
.atp-activity-icon.success { background: var(--atp-success); }

/* ============================================
   MODAL
   ============================================ */
.atp-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.atp-modal {
    background: var(--atp-card-bg);
    border-radius: var(--atp-radius-md);
    padding: var(--atp-spacing-lg);
    max-width: 600px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
}

.atp-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--atp-spacing-md);
    padding-bottom: var(--atp-spacing-sm);
    border-bottom: 1px solid var(--atp-border);
}

.atp-modal-title {
    margin: 0;
    color: var(--atp-primary);
}

.atp-modal-close {
    background: none;
    border: none;
    color: var(--atp-text-muted);
    font-size: 1.5em;
    cursor: pointer;
}

.atp-modal-close:hover {
    color: var(--atp-text);
}

.atp-modal-footer {
    margin-top: var(--atp-spacing-lg);
    padding-top: var(--atp-spacing-md);
    border-top: 1px solid var(--atp-border);
    display: flex;
    justify-content: flex-end;
    gap: var(--atp-spacing-sm);
}

/* ============================================
   HEALTH INDICATORS
   ============================================ */
.atp-health-item {
    display: flex;
    flex-direction: column;
    gap: var(--atp-spacing-xs);
}

.atp-health-label {
    font-size: 12px;
    color: var(--atp-text-muted);
    text-transform: uppercase;
}

.atp-health-value {
    font-size: 14px;
    color: var(--atp-text);
    font-weight: 500;
}

/* ============================================
   UTILITY CLASSES
   ============================================ */
.atp-countdown {
    font-family: monospace;
    color: var(--atp-warning);
}

.atp-refresh-indicator {
    font-size: 11px;
    color: var(--atp-text-muted);
}

.atp-hidden { display: none !important; }
.atp-text-center { text-align: center; }
.atp-text-right { text-align: right; }
.atp-mt-0 { margin-top: 0; }
.atp-mb-0 { margin-bottom: 0; }
.atp-mt-lg { margin-top: var(--atp-spacing-lg); }
.atp-mb-lg { margin-bottom: var(--atp-spacing-lg); }

/* ============================================
   ANIMATIONS
   ============================================ */
@keyframes atp-spin {
    to { transform: rotate(360deg); }
}

.atp-spin {
    animation: atp-spin 1s linear infinite;
}

@keyframes atp-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.atp-pulse {
    animation: atp-pulse 2s ease-in-out infinite;
}

/* ============================================
   RESPONSIVE - Tablet (768px)
   ============================================ */
@media (max-width: 768px) {
    .atp-header {
        flex-direction: column;
        gap: var(--atp-spacing-md);
        text-align: center;
    }

    .atp-tabs {
        gap: 3px;
    }

    .atp-tab {
        padding: 8px 12px;
        font-size: 12px;
        flex: 1 1 auto;
        text-align: center;
        min-width: 70px;
    }

    .atp-tab i {
        margin-right: 5px;
    }

    .atp-form-row {
        grid-template-columns: 1fr;
    }

    .atp-grid {
        grid-template-columns: repeat(2, 1fr);
    }

    .atp-stat-card {
        padding: var(--atp-spacing-md);
    }

    .atp-stat-value {
        font-size: 1.5em;
    }

    .atp-table {
        font-size: 12px;
    }

    .atp-table th,
    .atp-table td {
        padding: 8px 10px;
    }

    .atp-table .filename,
    .atp-table .truncate {
        max-width: 120px;
    }

    .atp-section,
    .atp-card {
        padding: var(--atp-spacing-md);
    }

    /* Force single column on 2-column grids */
    div[style*="grid-template-columns: 1fr 1fr"] {
        grid-template-columns: 1fr !important;
    }
}

/* ============================================
   RESPONSIVE - Mobile (480px)
   ============================================ */
@media (max-width: 480px) {
    .atp-container {
        padding: var(--atp-spacing-sm);
    }

    .atp-tabs {
        gap: 2px;
    }

    .atp-tab {
        padding: 6px 8px;
        font-size: 11px;
        min-width: 50px;
    }

    .atp-tab i {
        margin-right: 0;
    }

    .atp-grid {
        grid-template-columns: 1fr 1fr;
    }

    .atp-stat-value {
        font-size: 1.2em;
    }

    .atp-table {
        font-size: 11px;
    }

    .atp-table th,
    .atp-table td {
        padding: 6px 8px;
    }

    .atp-log-viewer {
        max-height: 300px;
        font-size: 10px;
    }

    .atp-btn {
        padding: 6px 12px;
        font-size: 0.85em;
    }
}


/* Backwards compatibility aliases: --tb-* maps to --atp-* */
:root {
    --tb-primary: var(--atp-primary);
    --tb-primary-dark: var(--atp-primary-dark);
    --tb-success: var(--atp-success);
    --tb-danger: var(--atp-danger);
    --tb-warning: var(--atp-warning);
    --tb-info: var(--atp-info);
    --tb-bg: var(--atp-bg);
    --tb-card-bg: var(--atp-card-bg);
    --tb-text: var(--atp-text);
    --tb-text-muted: var(--atp-text-muted);
    --tb-border: var(--atp-border);
}



/* ============================================
   ATP BACKUP - CSS v2026.01.28
   ============================================ */

:root {
    --tb-primary: #e67e22;
    --tb-primary-dark: #d35400;
    --tb-success: #27ae60;
    --tb-danger: #c0392b;
    --tb-warning: #f39c12;
    --tb-info: #3498db;
    --tb-bg: var(--body-background, #1a1a1a);
    --tb-card-bg: var(--card-background, #262626);
    --tb-text: var(--text-color, #e0e0e0);
    --tb-text-muted: var(--text-muted, #888);
    --tb-border: var(--border-color, #3a3a3a);
}

.tb-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

/* Header */
.tb-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid var(--tb-border);
}

.tb-title {
    display: flex;
    align-items: center;
    gap: 15px;
}

.tb-title h1 {
    margin: 0;
    color: var(--tb-primary);
    font-size: 1.8em;
}

.tb-status-badge {
    padding: 0 16px;
    border-radius: 4px;
    font-size: 0.85em;
    font-weight: 600;
    white-space: nowrap;
    height: 36px;
    line-height: 36px;
    display: inline-block;
}

.tb-status-badge i {
    font-size: 0.6em;
    margin-right: 6px;
}

.tb-status-running { background: var(--tb-success); color: white; }
.tb-status-stopped { background: var(--tb-danger); color: white; }

.tb-header-actions {
    display: flex;
    gap: 10px;
    align-items: center;
}

.tb-header-actions .tb-btn {
    height: 36px;
    line-height: 20px;
    padding: 8px 16px;
    border-radius: 4px;
}

.tb-version {
    color: var(--tb-text-muted);
    font-size: 0.85em;
}

/* Tabs - ESC style (full button highlight) */
.tb-tabs {
    display: flex;
    gap: 5px;
    margin-bottom: 20px;
    border-bottom: 1px solid var(--tb-border);
    padding-bottom: 10px;
    flex-wrap: wrap;
}

.tb-tab {
    padding: 10px 20px;
    margin: 0;
    background: var(--tb-card-bg);
    border: 1px solid var(--tb-border);
    border-radius: 5px 5px 0 0;
    color: var(--tb-text-muted);
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    transition: all 0.2s ease;
    font-family: inherit;
}

.tb-tab:hover {
    background: rgba(255,255,255,0.05);
    color: var(--tb-text);
}

.tb-tab.active {
    background: var(--tb-primary);
    color: #fff;
    border-color: var(--tb-primary);
}

.tb-tab i {
    margin-right: 8px;
}

/* Tab Content */
.tb-tab-content {
    display: none;
}

.tb-tab-content.active {
    display: block;
}

/* Cards */
.tb-card {
    background: var(--tb-card-bg);
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
    border: 1px solid var(--tb-border);
    overflow: hidden; /* Ensures scrollbar stays within card on mobile */
}

.tb-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--tb-border);
}

.tb-card-title {
    margin: 0;
    font-size: 1.1em;
    color: var(--tb-primary);
}

/* Dashboard Stats Grid */
.tb-stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

/* Dashboard two-column grid (Upcoming Jobs / Recent Activity) */
.tb-dashboard-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}

.tb-stat-card {
    background: var(--tb-card-bg);
    border-radius: 8px;
    padding: 20px;
    border: 1px solid var(--tb-border);
    text-align: center;
}

.tb-stat-icon {
    font-size: 2em;
    margin-bottom: 10px;
    color: var(--tb-primary);
}

.tb-stat-value {
    font-size: 1.8em;
    font-weight: bold;
    color: var(--tb-text);
}

.tb-stat-label {
    color: var(--tb-text-muted);
    font-size: 0.9em;
    margin-top: 5px;
}

/* Buttons */
.tb-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s;
}

.tb-btn-primary {
    background: var(--tb-primary);
    color: white;
}

.tb-btn-primary:hover {
    background: var(--tb-primary-dark);
}

.tb-btn-success {
    background: var(--tb-success);
    color: white;
}

.tb-btn-danger {
    background: var(--tb-danger);
    color: white;
}

.tb-btn-secondary {
    background: var(--tb-border);
    color: var(--tb-text);
}

.tb-btn-sm {
    padding: 5px 10px;
    font-size: 0.85em;
}

.tb-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Tables - Responsive with wrapper */
.tb-table-wrapper {
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    margin-bottom: 15px;
}

.tb-table {
    width: 100%;
    border-collapse: collapse;
    min-width: 600px;
}

.tb-table th,
.tb-table td {
    padding: 12px;
    text-align: left;
    border-bottom: 1px solid var(--tb-border);
}

.tb-table th {
    color: var(--tb-primary);
    font-weight: 600;
    font-size: 11px;
    text-transform: uppercase;
    white-space: nowrap;
    background: rgba(0,0,0,0.2);
}

.tb-table tr:hover {
    background: rgba(255,255,255,0.02);
}

.tb-table .truncate {
    max-width: 200px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* Forms */
.tb-form-group {
    margin-bottom: 15px;
}

.tb-form-group label {
    display: block;
    margin-bottom: 5px;
    color: var(--tb-text);
    font-weight: 500;
}

.tb-form-group input,
.tb-form-group select,
.tb-form-group textarea {
    width: 100%;
    padding: 10px;
    border: 1px solid var(--tb-border);
    border-radius: 4px;
    background: var(--tb-bg);
    color: var(--tb-text);
    font-size: 0.95em;
}

.tb-form-group input:focus,
.tb-form-group select:focus,
.tb-form-group textarea:focus {
    outline: none;
    border-color: var(--tb-primary);
}

.tb-form-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.tb-form-hint {
    font-size: 0.85em;
    color: var(--tb-text-muted);
    margin-top: 4px;
}

/* Status badges */
.tb-badge {
    display: inline-block;
    padding: 3px 10px;
    border-radius: 12px;
    font-size: 0.8em;
    font-weight: 600;
}

.tb-badge-success { background: rgba(39, 174, 96, 0.2); color: #27ae60; }
.tb-badge-danger { background: rgba(192, 57, 43, 0.2); color: #e74c3c; }
.tb-badge-warning { background: rgba(243, 156, 18, 0.2); color: #f39c12; }
.tb-badge-info { background: rgba(52, 152, 219, 0.2); color: #3498db; }
.tb-badge-secondary { background: rgba(136, 136, 136, 0.2); color: #888; }

/* Log viewer */
.tb-log-viewer {
    background: #1a1a1a;
    border: 1px solid var(--tb-border);
    border-radius: 4px;
    padding: 15px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 0.85em;
    line-height: 1.5;
    max-height: 500px;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-all;
}

/* Modal */
.tb-modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.7);
    z-index: 1000;
    align-items: center;
    justify-content: center;
}

.tb-modal-overlay.active {
    display: flex;
}

.tb-modal {
    background: var(--tb-card-bg);
    border-radius: 8px;
    width: 90%;
    max-width: 700px;
    max-height: 90vh;
    overflow-y: auto;
    border: 1px solid var(--tb-border);
}

.tb-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid var(--tb-border);
}

.tb-modal-header h3 {
    margin: 0;
    color: var(--tb-primary);
}

.tb-modal-close {
    background: none;
    border: none;
    color: var(--tb-text-muted);
    font-size: 1.5em;
    cursor: pointer;
}

.tb-modal-body {
    padding: 20px;
}

.tb-modal-footer {
    padding: 15px 20px;
    border-top: 1px solid var(--tb-border);
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

/* Animations */
@keyframes tb-spin {
    to { transform: rotate(360deg); }
}

.tb-spin {
    animation: tb-spin 1s linear infinite;
}

/* Responsive */
@media (max-width: 768px) {
    .tb-header {
        flex-direction: column;
        gap: 15px;
        text-align: center;
    }

    .tb-tabs {
        gap: 3px;
    }

    .tb-tab {
        padding: 8px 12px;
        font-size: 12px;
        flex: 1 1 auto;
        text-align: center;
        min-width: 70px;
    }

    .tb-tab i {
        margin-right: 5px;
    }

    .tb-form-row {
        grid-template-columns: 1fr;
    }

    .tb-table {
        font-size: 12px;
    }

    .tb-table th,
    .tb-table td {
        padding: 8px 10px;
    }

    .tb-table .truncate {
        max-width: 120px;
    }

    .tb-stats-grid {
        grid-template-columns: repeat(2, 1fr);
    }

    /* Stack Upcoming Jobs and Recent Activity vertically on tablet/mobile */
    .tb-dashboard-grid {
        grid-template-columns: 1fr;
    }

    .tb-table-wrapper {
        margin-left: -20px;
        margin-right: -20px;
        padding-left: 20px;
        padding-right: 20px;
        width: calc(100% + 40px);
    }
}

@media (max-width: 480px) {
    .tb-tabs {
        gap: 2px;
    }

    .tb-tab {
        padding: 6px 8px;
        font-size: 11px;
        min-width: 50px;
    }

    .tb-tab i {
        margin-right: 0;
    }

    .tb-table {
        font-size: 11px;
    }

    .tb-table th,
    .tb-table td {
        padding: 6px 8px;
    }

    .tb-stats-grid {
        grid-template-columns: 1fr 1fr;
    }
}

/* Checkbox styling */
.tb-checkbox-label {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    padding: 8px 0;
}

.tb-checkbox-label input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: var(--tb-primary);
}

.tb-checkbox-label span {
    color: var(--tb-text);
}

.tb-checkbox-group {
    display: flex;
    gap: 30px;
    padding: 10px 0;
    border-top: 1px solid var(--tb-border);
    margin-top: 15px;
}

/* Large button */
.tb-btn-lg {
    padding: 12px 30px;
    font-size: 1em;
}

/* Extra small button for inline use */
.tb-btn-xs {
    padding: 2px 8px;
    font-size: 0.75em;
    border-radius: 3px;
}

/* Actions column */
.tb-actions {
    white-space: nowrap;
}

.tb-actions .tb-btn {
    margin-right: 5px;
}

.tb-actions .tb-btn:last-child {
    margin-right: 0;
}

/* Grid layouts for settings */
@media (max-width: 900px) {
    #tab-settings > div:first-child {
        grid-template-columns: 1fr;
    }
}

/* Toggle switch */
.tb-toggle {
    position: relative;
    display: inline-block;
    width: 44px;
    height: 24px;
}

.tb-toggle input {
    opacity: 0;
    width: 0;
    height: 0;
}

.tb-toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #555;
    transition: 0.3s;
    border-radius: 24px;
}

.tb-toggle-slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
}

.tb-toggle input:checked + .tb-toggle-slider {
    background-color: var(--tb-success);
}

.tb-toggle input:checked + .tb-toggle-slider:before {
    transform: translateX(20px);
}
</style>

<div class="tb-container">
    <!-- Header -->
    <div class="tb-header">
        <div class="tb-title">
            <i class="fas fa-shield-alt fa-2x" style="color: var(--tb-primary)"></i>
            <h1>ATP Backup</h1>
        </div>
        <div class="tb-header-actions">
            <span id="serviceStatus" class="tb-status-badge <?=$isRunning ? 'tb-status-running' : 'tb-status-stopped'?>">
                <i class="fas fa-circle"></i><?=$isRunning ? 'Running' : 'Stopped'?><?php if ($isRunning && $pid): ?> (PID <?=$pid?>)<?php endif; ?>
            </span>
            <button class="tb-btn <?=$isRunning ? 'tb-btn-danger' : 'tb-btn-success'?>" onclick="toggleService()" id="serviceToggleBtn">
                <i class="fas fa-<?=$isRunning ? 'stop' : 'play'?>" id="serviceToggleIcon"></i>
                <span id="serviceToggleText"><?=$isRunning ? 'Stop' : 'Start'?></span>
            </button>
            <span class="tb-version">v2026.01.30</span>
        </div>
    </div>
    
    <!-- Tabs -->
    <div class="tb-tabs">
        <button class="tb-tab active" onclick="showTab('dashboard')">
            <i class="fas fa-tachometer-alt"></i> Dashboard
        </button>
        <button class="tb-tab" onclick="showTab('jobs')">
            <i class="fas fa-tasks"></i> Jobs
        </button>
        <button class="tb-tab" onclick="showTab('history')">
            <i class="fas fa-history"></i> History
        </button>
        <button class="tb-tab" onclick="showTab('stats')">
            <i class="fas fa-chart-bar"></i> Statistics
        </button>
        <button class="tb-tab" onclick="showTab('logs')">
            <i class="fas fa-file-alt"></i> Logs
        </button>
        <button class="tb-tab" onclick="showTab('settings')">
            <i class="fas fa-cog"></i> Settings
        </button>
    </div>
    
    <!-- Dashboard Tab -->
    <div id="tab-dashboard" class="tb-tab-content active">
        <div class="tb-stats-grid">
            <div class="tb-stat-card">
                <div class="tb-stat-icon"><i class="fas fa-tasks"></i></div>
                <div class="tb-stat-value" id="statActiveJobs">-</div>
                <div class="tb-stat-label">Active Jobs</div>
            </div>
            <div class="tb-stat-card">
                <div class="tb-stat-icon"><i class="fas fa-check-circle" style="color: var(--tb-success)"></i></div>
                <div class="tb-stat-value" id="statSuccessful">-</div>
                <div class="tb-stat-label">Successful (30d)</div>
            </div>
            <div class="tb-stat-card">
                <div class="tb-stat-icon"><i class="fas fa-times-circle" style="color: var(--tb-danger)"></i></div>
                <div class="tb-stat-value" id="statFailed">-</div>
                <div class="tb-stat-label">Failed (30d)</div>
            </div>
            <div class="tb-stat-card">
                <div class="tb-stat-icon"><i class="fas fa-database"></i></div>
                <div class="tb-stat-value" id="statTotalData">-</div>
                <div class="tb-stat-label">Data Transferred</div>
            </div>
        </div>
        
        <div class="tb-card">
            <div class="tb-card-header">
                <h3 class="tb-card-title"><i class="fas fa-running"></i> Current Status</h3>
                <button class="tb-btn tb-btn-sm tb-btn-secondary" onclick="refreshDashboard()">
                    <i class="fas fa-sync-alt"></i> Refresh
                </button>
            </div>
            <div id="currentStatus">
                <p style="color: var(--tb-text-muted)">Loading...</p>
            </div>
        </div>
        
        <div class="tb-dashboard-grid">
            <div class="tb-card">
                <div class="tb-card-header">
                    <h3 class="tb-card-title"><i class="fas fa-calendar-alt"></i> Upcoming Jobs</h3>
                </div>
                <div id="upcomingJobs">
                    <p style="color: var(--tb-text-muted)">Loading...</p>
                </div>
            </div>

            <div class="tb-card">
                <div class="tb-card-header">
                    <h3 class="tb-card-title"><i class="fas fa-clock"></i> Recent Activity</h3>
                </div>
                <div id="recentActivity">
                    <p style="color: var(--tb-text-muted)">Loading...</p>
                </div>
            </div>
        </div>
        
        <!-- Backup Health -->
        <div class="tb-card" style="margin-top: 20px;">
            <div class="tb-card-header">
                <h3 class="tb-card-title"><i class="fas fa-heartbeat"></i> Backup Health</h3>
            </div>
            <div id="backupHealth">
                <p style="color: var(--tb-text-muted)">Loading...</p>
            </div>
        </div>
    </div>
    
    <!-- Jobs Tab -->
    <div id="tab-jobs" class="tb-tab-content">
        <div class="tb-card">
            <div class="tb-card-header">
                <h3 class="tb-card-title"><i class="fas fa-tasks"></i> Backup Jobs</h3>
                <button class="tb-btn tb-btn-primary" onclick="showJobModal()">
                    <i class="fas fa-plus"></i> Add Job
                </button>
            </div>
            <div id="jobsList">
                <p style="color: var(--tb-text-muted)">Loading...</p>
            </div>
        </div>
    </div>
    
    <!-- History Tab -->
    <div id="tab-history" class="tb-tab-content">
        <div class="tb-card">
            <div class="tb-card-header">
                <h3 class="tb-card-title"><i class="fas fa-history"></i> Backup History</h3>
                <select id="historyFilter" onchange="loadHistory()" style="padding: 5px 10px; background: var(--tb-bg); color: var(--tb-text); border: 1px solid var(--tb-border); border-radius: 4px;">
                    <option value="">All Jobs</option>
                </select>
            </div>
            <div id="historyList">
                <p style="color: var(--tb-text-muted)">Loading...</p>
            </div>
        </div>
    </div>
    
    <!-- Statistics Tab -->
    <div id="tab-stats" class="tb-tab-content">
        <div class="tb-card">
            <div class="tb-card-header">
                <h3 class="tb-card-title"><i class="fas fa-chart-bar"></i> Backup Statistics (30 Days)</h3>
            </div>
            <div id="statsContainer">
                <canvas id="statsChart" height="100"></canvas>
                <div id="statsEmpty" style="display: none; text-align: center; padding: 40px; color: var(--tb-text-muted);">
                    <i class="fas fa-chart-line" style="font-size: 3em; margin-bottom: 15px; opacity: 0.5;"></i>
                    <p>No backup data yet</p>
                    <p style="font-size: 0.9em;">Run some backups to see statistics here</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Logs Tab -->
    <div id="tab-logs" class="tb-tab-content">
        <div class="tb-card">
            <div class="tb-card-header">
                <h3 class="tb-card-title"><i class="fas fa-file-alt"></i> Service Log</h3>
                <div>
                    <button class="tb-btn tb-btn-sm tb-btn-secondary" onclick="loadLogs()">
                        <i class="fas fa-sync-alt"></i> Refresh
                    </button>
                </div>
            </div>
            <div id="logViewer" class="tb-log-viewer">Loading...</div>
        </div>
    </div>
    
    <!-- Settings Tab -->
    <div id="tab-settings" class="tb-tab-content">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <!-- Left Column -->
            <div>
                <div class="tb-card">
                    <div class="tb-card-header">
                        <h3 class="tb-card-title"><i class="fas fa-cog"></i> General</h3>
                    </div>
                    <form id="settingsForm">
                        <div class="tb-form-group">
                            <label>Log Level</label>
                            <select name="LOG_LEVEL" id="setLogLevel">
                                <option value="DEBUG">DEBUG - All details</option>
                                <option value="INFO">INFO - Normal</option>
                                <option value="WARNING">WARNING - Issues only</option>
                                <option value="ERROR">ERROR - Errors only</option>
                            </select>
                        </div>
                        <div class="tb-form-group">
                            <label>Default Bandwidth Limit (KB/s)</label>
                            <input type="number" name="DEFAULT_BANDWIDTH_LIMIT" id="setBandwidth" min="0" placeholder="0 = unlimited">
                            <div class="tb-form-hint">Applied to new jobs. 0 = no limit.</div>
                        </div>
                </div>
                
                <div class="tb-card">
                    <div class="tb-card-header">
                        <h3 class="tb-card-title"><i class="fas fa-redo"></i> Auto-Retry</h3>
                    </div>
                    <div class="tb-form-group">
                        <label class="tb-checkbox-label">
                            <input type="checkbox" name="RETRY_ON_FAILURE" id="setRetryOnFailure">
                            <span>Automatically retry failed jobs</span>
                        </label>
                    </div>
                    <div class="tb-form-row">
                        <div class="tb-form-group">
                            <label>Retry Interval</label>
                            <input type="number" name="RETRY_INTERVAL_MINUTES" id="setRetryInterval" min="5" max="1440" value="60">
                            <div class="tb-form-hint">Minutes between retries</div>
                        </div>
                        <div class="tb-form-group">
                            <label>Max Attempts</label>
                            <input type="number" name="RETRY_MAX_ATTEMPTS" id="setRetryMax" min="1" max="10" value="3">
                        </div>
                    </div>
                </div>
                
                <div class="tb-card">
                    <div class="tb-card-header">
                        <h3 class="tb-card-title"><i class="fas fa-network-wired"></i> Wake-on-LAN</h3>
                    </div>
                    <div class="tb-form-row">
                        <div class="tb-form-group">
                            <label>Wait Timeout</label>
                            <input type="number" name="WOL_WAIT_TIMEOUT" id="setWolTimeout" min="30" max="600" value="120">
                            <div class="tb-form-hint">Seconds to wait for host</div>
                        </div>
                        <div class="tb-form-group">
                            <label>Ping Interval</label>
                            <input type="number" name="WOL_PING_INTERVAL" id="setWolInterval" min="1" max="30" value="5">
                            <div class="tb-form-hint">Seconds between pings</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Column -->
            <div>
                <div class="tb-card">
                    <div class="tb-card-header">
                        <h3 class="tb-card-title"><i class="fab fa-discord"></i> Discord Notifications</h3>
                    </div>
                    <div class="tb-form-group">
                        <label>Webhook URL</label>
                        <input type="text" name="DISCORD_WEBHOOK_URL" id="setDiscordUrl" placeholder="https://discord.com/api/webhooks/...">
                    </div>
                    <div class="tb-form-group">
                        <label>Notify When</label>
                        <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 5px;">
                            <label class="tb-checkbox-label" style="padding: 0;">
                                <input type="checkbox" name="DISCORD_NOTIFY_START" id="setDiscordStart" checked>
                                <span>Backup started</span>
                            </label>
                            <label class="tb-checkbox-label" style="padding: 0;">
                                <input type="checkbox" name="DISCORD_NOTIFY_SUCCESS" id="setDiscordSuccess" checked>
                                <span>Backup completed successfully</span>
                            </label>
                            <label class="tb-checkbox-label" style="padding: 0;">
                                <input type="checkbox" name="DISCORD_NOTIFY_FAILURE" id="setDiscordFailure" checked>
                                <span>Backup failed</span>
                            </label>
                        </div>
                    </div>
                    <div class="tb-form-group" style="border-top: 1px solid var(--tb-border); padding-top: 15px; margin-top: 10px;">
                        <label class="tb-checkbox-label" style="padding: 0;">
                            <input type="checkbox" name="DISCORD_DAILY_SUMMARY" id="setDailySummary">
                            <span>Send daily summary</span>
                        </label>
                        <div class="tb-form-row" style="margin-top: 10px;">
                            <div class="tb-form-group" style="margin-bottom: 0;">
                                <label>Summary Time</label>
                                <input type="number" name="DISCORD_SUMMARY_HOUR" id="setSummaryHour" min="0" max="23" value="20">
                                <div class="tb-form-hint">Hour (0-23)</div>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="tb-btn tb-btn-secondary" onclick="testDiscord()" style="margin-top: 10px;">
                        <i class="fab fa-discord"></i> Send Test
                    </button>
                </div>
                
                <div class="tb-card">
                    <div class="tb-card-header">
                        <h3 class="tb-card-title"><i class="fas fa-bell"></i> Unraid Notifications</h3>
                    </div>
                    <div class="tb-form-group">
                        <label class="tb-checkbox-label">
                            <input type="checkbox" name="UNRAID_NOTIFICATIONS" id="setUnraidNotify" checked>
                            <span>Enable Unraid notifications</span>
                        </label>
                        <div class="tb-form-hint">Shows in Unraid notification panel</div>
                    </div>
                </div>
                
                <div class="tb-card">
                    <div class="tb-card-header">
                        <h3 class="tb-card-title"><i class="fas fa-database"></i> Data Management</h3>
                    </div>
                    <div class="tb-form-group">
                        <label>Job History Retention</label>
                        <input type="number" name="HISTORY_RETENTION_DAYS" id="setHistoryDays" min="0" max="365" value="90">
                        <div class="tb-form-hint">Days to keep backup run records in database (0 = forever). This is NOT backup file retention - configure that per job.</div>
                    </div>
                    <div class="tb-form-group">
                        <label>Log File Max Size (KB)</label>
                        <input type="number" name="LOG_MAX_SIZE_KB" id="setLogMaxSize" min="100" max="100000" value="5000">
                        <div class="tb-form-hint">Maximum log file size before rotation (default 5MB)</div>
                    </div>
                    <div class="tb-form-group">
                        <label>Keep Rotated Logs</label>
                        <input type="number" name="LOG_KEEP_COUNT" id="setLogKeepCount" min="1" max="30" value="5">
                        <div class="tb-form-hint">Number of old log files to keep</div>
                    </div>
                    
                    <div style="border-top: 1px solid var(--tb-border); margin-top: 15px; padding-top: 15px;">
                        <label style="margin-bottom: 10px; display: block;">Database Actions</label>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button type="button" class="tb-btn tb-btn-secondary" onclick="clearHistory()">
                                <i class="fas fa-history"></i> Clear History
                            </button>
                            <button type="button" class="tb-btn tb-btn-secondary" onclick="resetStatistics()">
                                <i class="fas fa-chart-bar"></i> Reset Stats
                            </button>
                            <button type="button" class="tb-btn tb-btn-danger" onclick="resetDatabase()">
                                <i class="fas fa-trash-alt"></i> Full Reset
                            </button>
                        </div>
                        <div class="tb-form-hint" style="margin-top: 8px;">Clear History removes backup logs. Reset Stats clears statistics. Full Reset deletes all data (jobs kept).</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 20px; text-align: center;">
            <button type="submit" class="tb-btn tb-btn-primary tb-btn-lg">
                <i class="fas fa-save"></i> Save All Settings
            </button>
        </div>
        </form>
    </div>
</div>

<!-- Job Modal -->
<div id="jobModal" class="tb-modal-overlay">
    <div class="tb-modal">
        <div class="tb-modal-header">
            <h3 id="jobModalTitle">Add Backup Job</h3>
            <button class="tb-modal-close" onclick="closeJobModal()">&times;</button>
        </div>
        <div class="tb-modal-body">
            <form id="jobForm">
                <input type="hidden" id="jobId" name="id">
                
                <div class="tb-form-group">
                    <label>Job Name *</label>
                    <input type="text" id="jobName" name="name" required placeholder="My Backup Job">
                </div>
                
                <div class="tb-form-group">
                    <label>Job Type *</label>
                    <select id="jobType" name="job_type" onchange="toggleJobFields()" required>
                        <option value="local">Local (Array to Share)</option>
                        <option value="remote_smb">Remote SMB</option>
                        <option value="remote_smb_wol">Remote SMB with WOL</option>
                    </select>
                </div>
                
                <div class="tb-form-group">
                    <label>Source Path *</label>
                    <input type="text" id="jobSource" name="source_path" required placeholder="/mnt/user/appdata">
                </div>
                
                <div class="tb-form-group">
                    <label>Destination Path</label>
                    <input type="text" id="jobDest" name="dest_path" placeholder="/mnt/user/backups">
                    <div class="tb-form-hint">For remote: subdirectory within mount point</div>
                </div>
                
                <!-- Remote fields -->
                <div id="remoteFields" style="display: none;">
                    <h4 style="color: var(--tb-primary); margin: 20px 0 10px;">
                        <i class="fas fa-server"></i> Remote Settings
                    </h4>
                    
                    <div class="tb-form-row">
                        <div class="tb-form-group">
                            <label>Remote Host (IP)</label>
                            <input type="text" id="jobRemoteHost" name="remote_host" placeholder="192.168.0.31">
                        </div>
                        <div class="tb-form-group">
                            <label>Remote Share</label>
                            <input type="text" id="jobRemoteShare" name="remote_share" placeholder="//192.168.0.31/backups">
                        </div>
                    </div>
                    
                    <div class="tb-form-group">
                        <label>Mount Point</label>
                        <input type="text" id="jobMountPoint" name="remote_mount_point" placeholder="/mnt/remotes/192.168.0.31_backups">
                        <div class="tb-form-hint">As configured in Unassigned Devices</div>
                    </div>
                </div>
                
                <!-- WOL fields -->
                <div id="wolFields" style="display: none;">
                    <h4 style="color: var(--tb-primary); margin: 20px 0 10px;">
                        <i class="fas fa-broadcast-tower"></i> Wake-on-LAN Settings
                    </h4>
                    
                    <div class="tb-form-row">
                        <div class="tb-form-group">
                            <label>MAC Address</label>
                            <input type="text" id="jobMac" name="mac_address" placeholder="AA:BB:CC:DD:EE:FF">
                        </div>
                        <div class="tb-form-group" style="display: flex; align-items: flex-end;">
                            <button type="button" class="tb-btn tb-btn-secondary" onclick="testWol()">
                                <i class="fas fa-bolt"></i> Test WOL
                            </button>
                        </div>
                    </div>
                    
                    <div class="tb-form-group">
                        <label>
                            <input type="checkbox" id="jobShutdown" name="shutdown_after">
                            Shutdown after backup (if woken by WOL)
                        </label>
                    </div>
                    
                    <div id="shutdownCredentials" style="display: none;">
                        <div class="tb-form-row">
                            <div class="tb-form-group">
                                <label>Windows Username</label>
                                <input type="text" id="jobRemoteUser" name="remote_user" placeholder="Administrator">
                            </div>
                            <div class="tb-form-group">
                                <label>Windows Password</label>
                                <input type="password" id="jobRemotePass" name="remote_pass">
                            </div>
                        </div>
                    </div>
                </div>
                
                <h4 style="color: var(--tb-primary); margin: 20px 0 10px;">
                    <i class="fas fa-clock"></i> Schedule
                </h4>
                
                <div class="tb-form-row">
                    <div class="tb-form-group">
                        <label>Schedule Type</label>
                        <select id="jobScheduleType" name="schedule_type" onchange="toggleScheduleFields()">
                            <option value="disabled">Disabled (Manual only)</option>
                            <option value="hourly">Hourly</option>
                            <option value="daily">Daily</option>
                            <option value="weekly">Weekly</option>
                            <option value="custom">Custom (Cron)</option>
                        </select>
                    </div>
                </div>
                
                <div id="scheduleFields" style="display: none;">
                    <div class="tb-form-row">
                        <div class="tb-form-group" id="scheduleHourGroup">
                            <label>Hour (0-23)</label>
                            <input type="number" id="jobScheduleHour" name="schedule_hour" min="0" max="23" value="2">
                        </div>
                        <div class="tb-form-group" id="scheduleMinuteGroup">
                            <label>Minute (0-59)</label>
                            <input type="number" id="jobScheduleMinute" name="schedule_minute" min="0" max="59" value="0">
                        </div>
                        <div class="tb-form-group" id="scheduleDayGroup" style="display: none;">
                            <label>Day of Week</label>
                            <select id="jobScheduleDay" name="schedule_day">
                                <option value="0">Monday</option>
                                <option value="1">Tuesday</option>
                                <option value="2">Wednesday</option>
                                <option value="3">Thursday</option>
                                <option value="4">Friday</option>
                                <option value="5">Saturday</option>
                                <option value="6">Sunday</option>
                            </select>
                        </div>
                    </div>
                    <div class="tb-form-group" id="scheduleCronGroup" style="display: none;">
                        <label>Cron Expression</label>
                        <input type="text" id="jobScheduleCron" name="schedule_cron" placeholder="0 2 * * *">
                        <div class="tb-form-hint">Format: minute hour day month weekday</div>
                    </div>
                </div>
                
                <h4 style="color: var(--tb-primary); margin: 20px 0 10px;">
                    <i class="fas fa-sliders-h"></i> Options
                </h4>
                
                <div class="tb-form-row">
                    <div class="tb-form-group">
                        <label>Bandwidth Limit (KB/s)</label>
                        <input type="number" id="jobBandwidth" name="bandwidth_limit" min="0" value="0" placeholder="0 = unlimited">
                        <div class="tb-form-hint">0 = use default from settings</div>
                    </div>
                </div>
                
                <h4 style="color: var(--tb-primary); margin: 20px 0 10px;">
                    <i class="fas fa-archive"></i> Backup Retention
                </h4>
                
                <div class="tb-form-row">
                    <div class="tb-form-group">
                        <label>Keep Backups (count)</label>
                        <input type="number" id="jobRetentionCount" name="retention_count" min="0" value="0">
                        <div class="tb-form-hint">Number of backups to keep (0 = unlimited)</div>
                    </div>
                    <div class="tb-form-group">
                        <label>Keep Backups (days)</label>
                        <input type="number" id="jobRetentionDays" name="retention_days" min="0" value="0">
                        <div class="tb-form-hint">Delete backups older than X days (0 = forever)</div>
                    </div>
                </div>
                
                <div class="tb-form-group">
                    <label>Exclude Patterns</label>
                    <div style="margin-bottom: 8px;">
                        <span style="font-size: 0.85em; color: var(--tb-text-muted);">Quick add:</span>
                        <button type="button" class="tb-btn tb-btn-xs" onclick="addExcludePreset('temp')" title="*.tmp, *.temp, *.swp, ~*">Temp files</button>
                        <button type="button" class="tb-btn tb-btn-xs" onclick="addExcludePreset('logs')" title="*.log, logs/">Logs</button>
                        <button type="button" class="tb-btn tb-btn-xs" onclick="addExcludePreset('cache')" title="cache/, .cache/, *cache*/">Cache</button>
                        <button type="button" class="tb-btn tb-btn-xs" onclick="addExcludePreset('os')" title="Thumbs.db, .DS_Store, desktop.ini">OS junk</button>
                        <button type="button" class="tb-btn tb-btn-xs" onclick="addExcludePreset('docker')" title="*.sock, docker.pid">Docker</button>
                    </div>
                    <textarea id="jobExcludes" name="exclude_patterns" rows="4" placeholder="*.tmp&#10;*.log&#10;cache/&#10;Thumbs.db"></textarea>
                    <div class="tb-form-hint">One pattern per line. Use * for wildcards, / suffix for directories.</div>
                </div>
                
                <h4 style="color: var(--tb-primary); margin: 20px 0 10px;">
                    <i class="fas fa-terminal"></i> Pre/Post Scripts
                </h4>
                
                <div class="tb-form-group">
                    <label>Pre-Backup Script</label>
                    <input type="text" id="jobPreScript" name="pre_script" placeholder="/mnt/user/scripts/pre_backup.sh">
                    <div class="tb-form-hint">Script to run BEFORE backup starts (e.g., stop containers, dump DB)</div>
                </div>
                
                <div class="tb-form-group">
                    <label>Post-Backup Script</label>
                    <input type="text" id="jobPostScript" name="post_script" placeholder="/mnt/user/scripts/post_backup.sh">
                    <div class="tb-form-hint">Script to run AFTER backup completes (e.g., start containers)</div>
                </div>
                
                <div class="tb-checkbox-group">
                    <label class="tb-checkbox-label">
                        <input type="checkbox" id="jobEnabled" name="enabled" checked>
                        <span>Job Enabled</span>
                    </label>
                    <label class="tb-checkbox-label">
                        <input type="checkbox" id="jobRetryOnFailure" name="retry_on_failure" checked>
                        <span>Retry on Failure</span>
                    </label>
                </div>
            </form>
        </div>
        <div class="tb-modal-footer">
            <button class="tb-btn tb-btn-secondary" onclick="closeJobModal()">Cancel</button>
            <button class="tb-btn tb-btn-primary" onclick="saveJob()">
                <i class="fas fa-save"></i> Save Job
            </button>
        </div>
    </div>
</div>

<script>
// ============================================
// ATP BACKUP - JavaScript v2026.01.28
// ============================================

const TB = {
    ajaxUrl: '/plugins/atp_backup/include/ajax.php',
    refreshInterval: null,
    statsChart: null
};

// ====== Tab Navigation ======

function showTab(tabName) {
    document.querySelectorAll('.tb-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tb-tab-content').forEach(t => t.classList.remove('active'));
    
    document.querySelector(`.tb-tab[onclick="showTab('${tabName}')"]`).classList.add('active');
    document.getElementById(`tab-${tabName}`).classList.add('active');
    
    // Load data for tab
    switch(tabName) {
        case 'dashboard': refreshDashboard(); break;
        case 'jobs': loadJobs(); break;
        case 'history': loadHistory(); break;
        case 'stats': loadStats(); break;
        case 'logs': loadLogs(); break;
        case 'settings': loadSettings(); break;
    }
}

// ====== API Helper ======

async function apiCall(action, params = {}) {
    const url = new URL(TB.ajaxUrl, window.location.origin);
    url.searchParams.set('action', action);
    
    for (const [key, value] of Object.entries(params)) {
        if (value !== undefined && value !== null) {
            url.searchParams.set(key, value);
        }
    }
    
    try {
        const response = await fetch(url);
        return await response.json();
    } catch (e) {
        console.error('API Error:', e);
        return { success: false, error: e.message };
    }
}

async function apiPost(action, data = {}) {
    const url = new URL(TB.ajaxUrl, window.location.origin);
    url.searchParams.set('action', action);
    
    // Add csrf_token to data for Unraid security
    data.csrf_token = csrf_token;
    
    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams(data).toString()
        });
        return await response.json();
    } catch (e) {
        console.error('API Error:', e);
        return { success: false, error: e.message };
    }
}

// ====== Dashboard ======

async function refreshDashboard() {
    // Load status
    const status = await apiCall('status');
    const statusDiv = document.getElementById('currentStatus');
    
    if (status.success) {
        if (status.backup?.running) {
            statusDiv.innerHTML = `
                <div style="display: flex; align-items: center; gap: 15px;">
                    <i class="fas fa-sync-alt tb-spin" style="font-size: 2em; color: var(--tb-primary)"></i>
                    <div>
                        <strong>Running:</strong> ${status.backup.job_name}<br>
                        <small style="color: var(--tb-text-muted)">Phase: ${status.backup.progress?.phase || 'running'}</small>
                    </div>
                </div>
            `;
        } else {
            statusDiv.innerHTML = `
                <p><i class="fas fa-check-circle" style="color: var(--tb-success)"></i> No backup currently running</p>
                <p style="color: var(--tb-text-muted); font-size: 0.9em;">
                    Uptime: ${formatDuration(status.uptime)} |
                    Unassigned Devices: ${status.ud_available ? '<span style="color: var(--tb-success)">Available</span>' : '<span style="color: var(--tb-danger)">Not found</span>'}
                </p>
            `;
        }
    } else {
        statusDiv.innerHTML = `<p style="color: var(--tb-danger)"><i class="fas fa-exclamation-triangle"></i> Service not responding</p>`;
    }
    
    // Load stats
    const stats = await apiCall('get_stats', { days: 30 });
    if (stats.success) {
        const totals = stats.totals || {};
        document.getElementById('statSuccessful').textContent = totals.successful || 0;
        document.getElementById('statFailed').textContent = totals.failed || 0;
        document.getElementById('statTotalData').textContent = formatBytes(totals.total_bytes || 0);
    }
    
    // Load jobs for active count and upcoming
    const jobsResult = await apiCall('get_jobs');
    const upcomingDiv = document.getElementById('upcomingJobs');
    
    if (jobsResult.success && jobsResult.jobs) {
        const activeJobs = jobsResult.jobs.filter(j => j.enabled);
        document.getElementById('statActiveJobs').textContent = `${activeJobs.length}/${jobsResult.jobs.length}`;
        
        const scheduledJobs = activeJobs.filter(j => j.schedule_type !== 'disabled');
        
        if (scheduledJobs.length > 0) {
            let html = '<div class="tb-table-wrapper"><table class="tb-table"><tbody>';
            for (const job of scheduledJobs.slice(0, 5)) {
                const nextRun = calculateNextRun(job);
                html += `<tr>
                    <td>${job.name}</td>
                    <td style="text-align: right; color: var(--tb-text-muted);">${nextRun}</td>
                </tr>`;
            }
            html += '</tbody></table></div>';
            upcomingDiv.innerHTML = html;
        } else {
            upcomingDiv.innerHTML = '<p style="color: var(--tb-text-muted)">No scheduled jobs</p>';
        }
    } else {
        upcomingDiv.innerHTML = '<p style="color: var(--tb-text-muted)">No jobs configured</p>';
    }
    
    // Load recent activity
    const history = await apiCall('get_history', { limit: 5 });
    const activityDiv = document.getElementById('recentActivity');
    
    if (history.success && history.history?.length > 0) {
        let html = '<div class="tb-table-wrapper"><table class="tb-table"><tbody>';
        for (const h of history.history) {
            const statusBadge = h.status === 'completed' ? 'tb-badge-success' :
                               h.status === 'running' ? 'tb-badge-info' : 'tb-badge-danger';
            html += `<tr>
                <td>${h.job_name}${h.is_retry ? ' <span class="tb-badge tb-badge-warning">retry</span>' : ''}</td>
                <td><span class="tb-badge ${statusBadge}">${h.status}</span></td>
                <td style="text-align: right; color: var(--tb-text-muted);">${formatDate(h.started_at)}</td>
            </tr>`;
        }
        html += '</tbody></table></div>';
        activityDiv.innerHTML = html;
    } else {
        activityDiv.innerHTML = '<p style="color: var(--tb-text-muted)">No recent activity</p>';
    }
    
    // Load backup health
    loadBackupHealth();
}

function calculateNextRun(job) {
    const now = new Date();
    const hour = job.schedule_hour || 0;
    const minute = job.schedule_minute || 0;
    
    let next = new Date();
    next.setSeconds(0);
    next.setMilliseconds(0);
    
    switch (job.schedule_type) {
        case 'hourly':
            next.setMinutes(minute);
            if (next <= now) next.setHours(next.getHours() + 1);
            break;
        case 'daily':
            next.setHours(hour, minute);
            if (next <= now) next.setDate(next.getDate() + 1);
            break;
        case 'weekly':
            next.setHours(hour, minute);
            const targetDay = job.schedule_day || 0;
            const daysUntil = (targetDay - now.getDay() + 7) % 7;
            next.setDate(next.getDate() + (daysUntil === 0 && next <= now ? 7 : daysUntil));
            break;
        default:
            return job.schedule_cron || 'Custom';
    }
    
    const diff = next - now;
    const hours = Math.floor(diff / 3600000);
    const mins = Math.floor((diff % 3600000) / 60000);
    
    if (hours > 24) {
        const days = Math.floor(hours / 24);
        return `in ${days}d ${hours % 24}h`;
    } else if (hours > 0) {
        return `in ${hours}h ${mins}m`;
    } else {
        return `in ${mins}m`;
    }
}

// ====== Jobs ======

async function loadJobs() {
    const result = await apiCall('get_jobs');
    const jobsDiv = document.getElementById('jobsList');
    
    // Also populate history filter
    const historyFilter = document.getElementById('historyFilter');
    historyFilter.innerHTML = '<option value="">All Jobs</option>';
    
    if (result.success && result.jobs?.length > 0) {
        // Sort jobs by schedule time
        const sortedJobs = [...result.jobs].sort((a, b) => {
            if (a.schedule_type === 'disabled') return 1;
            if (b.schedule_type === 'disabled') return -1;
            const timeA = (a.schedule_hour || 0) * 60 + (a.schedule_minute || 0);
            const timeB = (b.schedule_hour || 0) * 60 + (b.schedule_minute || 0);
            return timeA - timeB;
        });
        
        let html = '<div class="tb-table-wrapper"><table class="tb-table"><thead><tr><th>Enabled</th><th>Name</th><th>Type</th><th>Schedule</th><th>Time</th><th>Last Run</th><th>Actions</th></tr></thead><tbody>';
        
        for (const job of sortedJobs) {
            const typeBadge = job.job_type === 'local' ? 'tb-badge-info' : 
                             job.job_type.includes('wol') ? 'tb-badge-warning' : 'tb-badge-secondary';
            const lastRun = job.last_run ? formatDate(job.last_run.started_at) : 'Never';
            const lastStatus = job.last_run ? 
                (job.last_run.status === 'completed' ? '' : '') : '';
            
            // Format schedule time
            let scheduleTime = '-';
            if (job.schedule_type !== 'disabled' && job.schedule_type !== 'cron') {
                const hour = String(job.schedule_hour || 0).padStart(2, '0');
                const minute = String(job.schedule_minute || 0).padStart(2, '0');
                scheduleTime = `${hour}:${minute}`;
            } else if (job.schedule_type === 'cron') {
                scheduleTime = job.schedule_cron || 'custom';
            }
            
            html += `<tr style="${job.enabled ? '' : 'opacity: 0.6;'}">
                <td style="text-align: center;">
                    <label class="tb-toggle">
                        <input type="checkbox" ${job.enabled ? 'checked' : ''} onchange="toggleJobEnabled(${job.id}, this.checked)">
                        <span class="tb-toggle-slider"></span>
                    </label>
                </td>
                <td>${job.name}</td>
                <td><span class="tb-badge ${typeBadge}">${job.job_type}</span></td>
                <td>${job.schedule_type === 'disabled' ? '<span style="color: var(--tb-text-muted)">Manual</span>' : job.schedule_type}</td>
                <td>${scheduleTime}</td>
                <td>${lastStatus} ${lastRun}</td>
                <td class="tb-actions">
                    <button class="tb-btn tb-btn-sm tb-btn-success" onclick="runJob(${job.id})" title="Run Now" ${job.enabled ? '' : 'disabled'}>
                        <i class="fas fa-play"></i> Run
                    </button>
                    <button class="tb-btn tb-btn-sm tb-btn-secondary" onclick="runJob(${job.id}, true)" title="Dry Run">
                        <i class="fas fa-vial"></i> Test
                    </button>
                    <button class="tb-btn tb-btn-sm tb-btn-secondary" onclick="editJob(${job.id})" title="Edit">
                        <i class="fas fa-edit"></i> Edit
                    </button>
                    <button class="tb-btn tb-btn-sm tb-btn-danger" onclick="deleteJob(${job.id})" title="Delete">
                        <i class="fas fa-trash"></i> Delete
                    </button>
                </td>
            </tr>`;
            
            historyFilter.innerHTML += `<option value="${job.id}">${job.name}</option>`;
        }
        
        html += '</tbody></table></div>';
        jobsDiv.innerHTML = html;
    } else {
        jobsDiv.innerHTML = '<p style="color: var(--tb-text-muted)">No backup jobs configured. Click "Add Job" to create one.</p>';
    }
}

async function toggleJobEnabled(jobId, enabled) {
    const result = await apiPost('toggle_job', { id: jobId, enabled: enabled ? 1 : 0 });
    
    if (result.success) {
        loadJobs(); // Refresh the list
        refreshDashboard(); // Update stats
    } else {
        alert('Error: ' + (result.error || 'Failed to toggle job'));
        loadJobs(); // Reload to show correct state
    }
}

async function runJob(jobId, dryRun = false) {
    const action = dryRun ? 'dry run' : 'run';
    if (!confirm(`Are you sure you want to ${action} this job?`)) return;
    
    const result = await apiCall('run_job', { id: jobId, dry_run: dryRun ? 'true' : 'false' });
    
    if (result.success) {
        alert(`Job started${dryRun ? ' (dry run)' : ''}!`);
        showTab('dashboard');
    } else {
        alert('Error: ' + (result.error || 'Unknown error'));
    }
}

async function deleteJob(jobId) {
    if (!confirm('Are you sure you want to delete this job? This will also delete all history for this job.')) return;
    
    const result = await apiCall('delete_job', { id: jobId });
    
    if (result.success) {
        loadJobs();
    } else {
        alert('Error: ' + (result.error || 'Unknown error'));
    }
}

// ====== Job Modal ======

function showJobModal(jobId = null) {
    document.getElementById('jobModalTitle').textContent = jobId ? 'Edit Backup Job' : 'Add Backup Job';
    document.getElementById('jobForm').reset();
    document.getElementById('jobId').value = jobId || '';
    document.getElementById('jobEnabled').checked = true;
    document.getElementById('jobRetryOnFailure').checked = true;
    
    toggleJobFields();
    toggleScheduleFields();
    
    if (jobId) {
        loadJobForEdit(jobId);
    }
    
    document.getElementById('jobModal').classList.add('active');
}

function closeJobModal() {
    document.getElementById('jobModal').classList.remove('active');
}

async function loadJobForEdit(jobId) {
    const result = await apiCall('get_job', { id: jobId });
    
    if (result.success && result.job) {
        const job = result.job;
        
        document.getElementById('jobName').value = job.name || '';
        document.getElementById('jobType').value = job.job_type || 'local';
        document.getElementById('jobSource').value = job.source_path || '';
        document.getElementById('jobDest').value = job.dest_path || '';
        document.getElementById('jobRemoteHost').value = job.remote_host || '';
        document.getElementById('jobRemoteShare').value = job.remote_share || '';
        document.getElementById('jobMountPoint').value = job.remote_mount_point || '';
        document.getElementById('jobMac').value = job.mac_address || '';
        document.getElementById('jobShutdown').checked = !!job.shutdown_after;
        document.getElementById('jobRemoteUser').value = job.remote_user || '';
        document.getElementById('jobRemotePass').value = job.remote_pass || '';
        document.getElementById('jobScheduleType').value = job.schedule_type || 'disabled';
        document.getElementById('jobScheduleHour').value = job.schedule_hour || 0;
        document.getElementById('jobScheduleMinute').value = job.schedule_minute || 0;
        document.getElementById('jobScheduleDay').value = job.schedule_day || 0;
        document.getElementById('jobScheduleCron').value = job.schedule_cron || '';
        document.getElementById('jobBandwidth').value = job.bandwidth_limit || 0;
        document.getElementById('jobRetentionCount').value = job.retention_count || 0;
        document.getElementById('jobRetentionDays').value = job.retention_days || 0;
        document.getElementById('jobEnabled').checked = !!job.enabled;
        document.getElementById('jobRetryOnFailure').checked = job.retry_on_failure !== 0;
        document.getElementById('jobExcludes').value = job.exclude_patterns || '';
        document.getElementById('jobPreScript').value = job.pre_script || '';
        document.getElementById('jobPostScript').value = job.post_script || '';
        
        toggleJobFields();
        toggleScheduleFields();
        toggleShutdownCredentials();
    }
}

function toggleJobFields() {
    const jobType = document.getElementById('jobType').value;
    
    document.getElementById('remoteFields').style.display = 
        jobType.includes('remote') ? 'block' : 'none';
    
    document.getElementById('wolFields').style.display = 
        jobType.includes('wol') ? 'block' : 'none';
}

function toggleScheduleFields() {
    const scheduleType = document.getElementById('jobScheduleType').value;
    const show = scheduleType !== 'disabled';
    
    document.getElementById('scheduleFields').style.display = show ? 'block' : 'none';
    document.getElementById('scheduleHourGroup').style.display = 
        ['daily', 'weekly'].includes(scheduleType) ? 'block' : 'none';
    document.getElementById('scheduleDayGroup').style.display = 
        scheduleType === 'weekly' ? 'block' : 'none';
    document.getElementById('scheduleCronGroup').style.display = 
        scheduleType === 'custom' ? 'block' : 'none';
}

function toggleShutdownCredentials() {
    const show = document.getElementById('jobShutdown').checked;
    document.getElementById('shutdownCredentials').style.display = show ? 'block' : 'none';
}

document.getElementById('jobShutdown').addEventListener('change', toggleShutdownCredentials);

async function saveJob() {
    const form = document.getElementById('jobForm');
    const formData = new FormData(form);
    const data = Object.fromEntries(formData.entries());
    
    // Convert checkboxes
    data.enabled = document.getElementById('jobEnabled').checked ? 1 : 0;
    data.shutdown_after = document.getElementById('jobShutdown').checked ? 1 : 0;
    data.use_wol = data.job_type.includes('wol') ? 1 : 0;
    data.retry_on_failure = document.getElementById('jobRetryOnFailure').checked ? 1 : 0;
    
    // Convert numeric fields
    data.retention_count = parseInt(data.retention_count) || 0;
    data.retention_days = parseInt(data.retention_days) || 0;
    data.bandwidth_limit = parseInt(data.bandwidth_limit) || 0;
    
    const jobId = data.id;
    delete data.id;
    
    let result;
    if (jobId) {
        result = await apiPost('update_job', { ...data, id: jobId });
    } else {
        result = await apiPost('create_job', data);
    }
    
    if (result.success) {
        closeJobModal();
        loadJobs();
    } else {
        alert('Error: ' + (result.error || 'Unknown error'));
    }
}

async function editJob(jobId) {
    showJobModal(jobId);
}

// ====== History ======

async function loadHistory() {
    const jobId = document.getElementById('historyFilter').value;
    const result = await apiCall('get_history', { limit: 100, job_id: jobId || undefined });
    const historyDiv = document.getElementById('historyList');
    
    if (result.success && result.history?.length > 0) {
        let html = '<div class="tb-table-wrapper"><table class="tb-table"><thead><tr><th>Job</th><th>Status</th><th>Started</th><th>Duration</th><th>Size</th><th>Speed</th></tr></thead><tbody>';
        
        for (const h of result.history) {
            const statusBadge = h.status === 'completed' ? 'tb-badge-success' : 
                               h.status === 'running' ? 'tb-badge-info' : 'tb-badge-danger';
            
            html += `<tr>
                <td>${h.job_name}${h.dry_run ? ' <span class="tb-badge tb-badge-secondary">dry run</span>' : ''}${h.is_retry ? ' <span class="tb-badge tb-badge-warning">retry</span>' : ''}</td>
                <td><span class="tb-badge ${statusBadge}">${h.status}</span></td>
                <td>${formatDate(h.started_at)}</td>
                <td>${formatDuration(h.duration_seconds)}</td>
                <td>${formatBytes(h.bytes_transferred)}</td>
                <td>${formatSpeed(h.transfer_speed_mbps)}</td>
            </tr>`;
        }
        
        html += '</tbody></table></div>';
        historyDiv.innerHTML = html;
    } else {
        historyDiv.innerHTML = '<p style="color: var(--tb-text-muted)">No backup history</p>';
    }
}

// ====== Statistics ======

async function loadStats() {
    const result = await apiCall('get_stats', { days: 30 });
    
    const chartCanvas = document.getElementById('statsChart');
    const emptyDiv = document.getElementById('statsEmpty');
    
    if (result.success && result.stats?.length > 0) {
        chartCanvas.style.display = 'block';
        emptyDiv.style.display = 'none';
        
        const labels = result.stats.map(s => s.date).reverse();
        const successful = result.stats.map(s => s.successful_jobs).reverse();
        const failed = result.stats.map(s => s.failed_jobs).reverse();
        
        const ctx = chartCanvas.getContext('2d');
        
        if (TB.statsChart) {
            TB.statsChart.destroy();
        }
        
        TB.statsChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Successful',
                        data: successful,
                        backgroundColor: 'rgba(39, 174, 96, 0.7)'
                    },
                    {
                        label: 'Failed',
                        data: failed,
                        backgroundColor: 'rgba(192, 57, 43, 0.7)'
                    }
                ]
            },
            options: {
                responsive: true,
                scales: {
                    x: { stacked: true },
                    y: { 
                        stacked: true, 
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1,
                            callback: function(value) {
                                if (Math.floor(value) === value) {
                                    return value;
                                }
                            }
                        }
                    }
                }
            }
        });
    } else {
        chartCanvas.style.display = 'none';
        emptyDiv.style.display = 'block';
    }
}

// ====== Logs ======

async function loadLogs() {
    const result = await apiCall('get_logs', { lines: 200 });
    const logDiv = document.getElementById('logViewer');
    
    if (result.success) {
        logDiv.textContent = result.logs || 'No logs available';
        logDiv.scrollTop = logDiv.scrollHeight;
    } else {
        logDiv.textContent = 'Error loading logs: ' + (result.error || 'Unknown');
    }
}

// ====== Settings ======

async function loadSettings() {
    const result = await apiCall('get_settings');
    
    if (result.success && result.settings) {
        const s = result.settings;
        document.getElementById('setLogLevel').value = s.LOG_LEVEL || 'INFO';
        document.getElementById('setBandwidth').value = s.DEFAULT_BANDWIDTH_LIMIT || 0;
        document.getElementById('setDiscordUrl').value = s.DISCORD_WEBHOOK_URL || '';
        document.getElementById('setDiscordStart').checked = s.DISCORD_NOTIFY_START !== false;
        document.getElementById('setDiscordSuccess').checked = s.DISCORD_NOTIFY_SUCCESS !== false;
        document.getElementById('setDiscordFailure').checked = s.DISCORD_NOTIFY_FAILURE !== false;
        document.getElementById('setDailySummary').checked = !!s.DISCORD_DAILY_SUMMARY;
        document.getElementById('setSummaryHour').value = s.DISCORD_SUMMARY_HOUR || 20;
        document.getElementById('setUnraidNotify').checked = s.UNRAID_NOTIFICATIONS !== false;
        document.getElementById('setRetryOnFailure').checked = s.RETRY_ON_FAILURE !== false;
        document.getElementById('setRetryInterval').value = s.RETRY_INTERVAL_MINUTES || 60;
        document.getElementById('setRetryMax').value = s.RETRY_MAX_ATTEMPTS || 3;
        document.getElementById('setWolTimeout').value = s.WOL_WAIT_TIMEOUT || 120;
        document.getElementById('setWolInterval').value = s.WOL_PING_INTERVAL || 5;
        document.getElementById('setHistoryDays').value = s.HISTORY_RETENTION_DAYS || 90;
        document.getElementById('setLogMaxSize').value = s.LOG_MAX_SIZE_KB || 5000;
        document.getElementById('setLogKeepCount').value = s.LOG_KEEP_COUNT || 5;
    }
}

document.getElementById('settingsForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const data = {
        LOG_LEVEL: document.getElementById('setLogLevel').value,
        DEFAULT_BANDWIDTH_LIMIT: parseInt(document.getElementById('setBandwidth').value) || 0,
        DISCORD_WEBHOOK_URL: document.getElementById('setDiscordUrl').value,
        DISCORD_NOTIFY_START: document.getElementById('setDiscordStart').checked,
        DISCORD_NOTIFY_SUCCESS: document.getElementById('setDiscordSuccess').checked,
        DISCORD_NOTIFY_FAILURE: document.getElementById('setDiscordFailure').checked,
        DISCORD_DAILY_SUMMARY: document.getElementById('setDailySummary').checked,
        DISCORD_SUMMARY_HOUR: parseInt(document.getElementById('setSummaryHour').value) || 20,
        UNRAID_NOTIFICATIONS: document.getElementById('setUnraidNotify').checked,
        RETRY_ON_FAILURE: document.getElementById('setRetryOnFailure').checked,
        RETRY_INTERVAL_MINUTES: parseInt(document.getElementById('setRetryInterval').value) || 60,
        RETRY_MAX_ATTEMPTS: parseInt(document.getElementById('setRetryMax').value) || 3,
        WOL_WAIT_TIMEOUT: parseInt(document.getElementById('setWolTimeout').value) || 120,
        WOL_PING_INTERVAL: parseInt(document.getElementById('setWolInterval').value) || 5,
        HISTORY_RETENTION_DAYS: parseInt(document.getElementById('setHistoryDays').value) || 90,
        LOG_MAX_SIZE_KB: parseInt(document.getElementById('setLogMaxSize').value) || 5000,
        LOG_KEEP_COUNT: parseInt(document.getElementById('setLogKeepCount').value) || 5
    };
    
    const result = await apiPost('save_settings', data);
    
    if (result.success) {
        alert('Settings saved successfully!');
    } else {
        alert('Error: ' + (result.error || 'Unknown error'));
    }
});

async function testDiscord() {
    const result = await apiCall('test_discord');
    
    if (result.success) {
        alert('Test notification sent! Check your Discord channel.');
    } else {
        alert('Error: ' + (result.error || 'Failed to send'));
    }
}

async function testWol() {
    const mac = document.getElementById('jobMac').value;
    if (!mac) {
        alert('Please enter a MAC address first');
        return;
    }
    
    const result = await apiCall('test_wol', { mac_address: mac });
    
    if (result.success) {
        alert('WOL packet sent to ' + mac);
    } else {
        alert('Error: ' + (result.error || 'Failed to send'));
    }
}

// ====== Database Management ======

async function clearHistory() {
    if (!confirm('This will delete all backup history records.\n\nYour jobs and settings will be kept.\n\nContinue?')) return;
    
    const result = await apiPost('clear_history');
    if (result.success) {
        alert('History cleared successfully!');
        refreshDashboard();
        loadHistory();
    } else {
        alert('Error: ' + (result.error || 'Failed to clear history'));
    }
}

async function resetStatistics() {
    if (!confirm('This will reset all backup statistics.\n\nHistory and jobs will be kept.\n\nContinue?')) return;
    
    const result = await apiPost('reset_statistics');
    if (result.success) {
        alert('Statistics reset successfully!');
        refreshDashboard();
        loadStats();
    } else {
        alert('Error: ' + (result.error || 'Failed to reset statistics'));
    }
}

async function resetDatabase() {
    if (!confirm(' FULL DATABASE RESET \n\nThis will delete:\n All backup history\n All statistics\n\nYour jobs and settings will be kept.\n\nAre you sure?')) return;
    if (!confirm('This cannot be undone. Type "RESET" in the next prompt to confirm.')) return;
    
    const confirmation = prompt('Type RESET to confirm:');
    if (confirmation !== 'RESET') {
        alert('Reset cancelled.');
        return;
    }
    
    const result = await apiPost('reset_database');
    if (result.success) {
        alert('Database reset complete!');
        refreshDashboard();
        loadHistory();
        loadStats();
    } else {
        alert('Error: ' + (result.error || 'Failed to reset database'));
    }
}

// ====== Exclude Pattern Presets ======

const excludePresets = {
    temp: ['*.tmp', '*.temp', '*.swp', '~*', '*.bak'],
    logs: ['*.log', 'logs/', '*.log.*'],
    cache: ['cache/', '.cache/', '*cache*/', 'Cache/'],
    os: ['Thumbs.db', '.DS_Store', 'desktop.ini', '._*', '.Spotlight-V100', '.Trashes'],
    docker: ['*.sock', 'docker.pid', '*.pid']
};

function addExcludePreset(preset) {
    const textarea = document.getElementById('jobExcludes');
    const currentPatterns = textarea.value.split('\n').filter(p => p.trim());
    const newPatterns = excludePresets[preset] || [];
    
    // Add only patterns that don't already exist
    for (const pattern of newPatterns) {
        if (!currentPatterns.includes(pattern)) {
            currentPatterns.push(pattern);
        }
    }
    
    textarea.value = currentPatterns.join('\n');
}

// ====== Backup Health ======

async function loadBackupHealth() {
    const healthDiv = document.getElementById('backupHealth');
    const jobsResult = await apiCall('get_jobs');
    
    if (!jobsResult.success || !jobsResult.jobs?.length) {
        healthDiv.innerHTML = '<p style="color: var(--tb-text-muted)">No jobs configured</p>';
        return;
    }
    
    let html = '<div class="tb-table-wrapper"><table class="tb-table"><thead><tr><th>Job</th><th>Last Backup</th><th>Status</th><th>Health</th></tr></thead><tbody>';
    
    const now = new Date();
    
    for (const job of jobsResult.jobs) {
        if (!job.enabled) continue;
        
        let lastBackup = 'Never';
        let status = '-';
        let health = '<span style="color: var(--tb-text-muted);">No data</span>';
        let healthIcon = '';
        
        if (job.last_run) {
            const lastDate = new Date(job.last_run.started_at);
            const hoursSince = (now - lastDate) / (1000 * 60 * 60);
            lastBackup = formatDate(job.last_run.started_at);
            status = job.last_run.status === 'completed' ? '' : '';
            
            if (job.last_run.status === 'completed') {
                if (hoursSince < 24) {
                    health = '<span style="color: var(--tb-success);">Healthy</span>';
                    healthIcon = '';
                } else if (hoursSince < 48) {
                    health = '<span style="color: var(--tb-warning);">Check Soon</span>';
                    healthIcon = '';
                } else {
                    health = '<span style="color: var(--tb-danger);">Overdue</span>';
                    healthIcon = '';
                }
            } else {
                health = '<span style="color: var(--tb-danger);">Failed</span>';
                healthIcon = '';
            }
        }
        
        html += `<tr>
            <td>${healthIcon} ${job.name}</td>
            <td>${lastBackup}</td>
            <td>${status}</td>
            <td>${health}</td>
        </tr>`;
    }
    
    html += '</tbody></table></div>';
    healthDiv.innerHTML = html;
}

// ====== Service Control ======

async function toggleService() {
    const statusEl = document.getElementById('serviceStatus');
    const btn = document.getElementById('serviceToggleBtn');
    const btnText = document.getElementById('serviceToggleText');
    const btnIcon = document.getElementById('serviceToggleIcon');
    const isRunning = statusEl.classList.contains('tb-status-running');
    const cmd = isRunning ? 'stop' : 'start';
    
    // Show loading state
    btn.disabled = true;
    btnIcon.className = 'fas fa-spinner tb-spin';
    btnText.textContent = cmd === 'start' ? 'Starting...' : 'Stopping...';
    
    const result = await apiCall('service', { cmd: cmd });
    
    if (result.success) {
        // Wait a moment for service to fully start/stop
        await new Promise(resolve => setTimeout(resolve, 1000));
        // Reload page to get fresh state including PID
        window.location.reload();
    } else {
        btn.disabled = false;
        alert('Error: ' + (result.output || result.error || 'Unknown'));
        // Restore button state
        btnIcon.className = isRunning ? 'fas fa-stop' : 'fas fa-play';
        btnText.textContent = isRunning ? 'Stop' : 'Start';
    }
}

// ====== Utilities ======

function formatBytes(bytes) {
    if (!bytes || bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function formatSpeed(bytesPerSec) {
    // Speed is stored as bytes/sec in database
    if (!bytesPerSec || bytesPerSec === 0) return '0 B/s';
    const k = 1024;
    const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
    const i = Math.min(Math.floor(Math.log(bytesPerSec) / Math.log(k)), sizes.length - 1);
    return parseFloat((bytesPerSec / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function formatDuration(seconds) {
    if (!seconds || seconds === 0) return '-';
    if (seconds < 60) return seconds + 's';
    if (seconds < 3600) return Math.floor(seconds / 60) + 'm ' + (seconds % 60) + 's';
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    return h + 'h ' + m + 'm';
}

function formatDate(dateStr) {
    if (!dateStr) return '-';
    const d = new Date(dateStr);
    return d.toLocaleDateString() + ' ' + d.toLocaleTimeString();
}

// ====== Init ======

document.addEventListener('DOMContentLoaded', () => {
    refreshDashboard();
    
    // Auto-refresh every 30 seconds
    TB.refreshInterval = setInterval(() => {
        if (document.getElementById('tab-dashboard').classList.contains('active')) {
            refreshDashboard();
        }
    }, 30000);
});



/* ============================================
   ATP SHARED JS - Injected by build.py
   ============================================ */
/**
 * ATP COMMON JS - v2026.01.30
 * Shared JavaScript utilities for all ATP plugins
 * Injected automatically by build.py
 */

var ATP = ATP || {};

/**
 * Initialize ATP utilities
 * @param {Object} options - Configuration options
 * @param {string} options.prefix - Plugin prefix (e.g., 'tb', 'esc')
 * @param {string} options.ajaxUrl - AJAX endpoint URL
 * @param {string} options.csrfToken - CSRF token for security
 */
ATP.init = function(options) {
    this.prefix = options.prefix || 'atp';
    this.ajaxUrl = options.ajaxUrl || '';
    this.csrfToken = options.csrfToken || '';
    this.refreshInterval = options.refreshInterval || 3000;
    this.refreshTimer = null;
    this.countdown = this.refreshInterval / 1000;
    this.currentTab = 'dashboard';

    console.log('[ATP] Initialized with prefix:', this.prefix);
};

/**
 * Get CSRF token from page or stored value
 * @returns {string} CSRF token
 */
ATP.getCsrfToken = function() {
    if (this.csrfToken) return this.csrfToken;

    // Try to get from hidden input
    var input = document.querySelector('input[name="csrf_token"]');
    if (input) return input.value;

    // Try to get from meta tag
    var meta = document.querySelector('meta[name="csrf-token"]');
    if (meta) return meta.getAttribute('content');

    return '';
};

/**
 * Make AJAX request with CSRF token
 * @param {string} action - AJAX action name
 * @param {Object} data - Additional data to send
 * @param {Function} callback - Success callback
 * @param {Function} errorCallback - Error callback
 */
ATP.ajax = function(action, data, callback, errorCallback) {
    var self = this;
    data = data || {};
    data.ajax = action;
    data.csrf_token = this.getCsrfToken();

    $.ajax({
        url: this.ajaxUrl,
        method: 'POST',
        data: data,
        dataType: 'json',
        timeout: 30000
    }).done(function(response) {
        if (callback) callback(response);
    }).fail(function(xhr, status, error) {
        console.error('[ATP] AJAX error:', action, status, error);
        if (errorCallback) {
            errorCallback(error, xhr);
        }
    });
};

/**
 * Make AJAX request with extended timeout (for long operations)
 * @param {string} action - AJAX action name
 * @param {Object} data - Additional data to send
 * @param {number} timeout - Timeout in milliseconds
 * @param {Function} callback - Success callback
 * @param {Function} errorCallback - Error callback
 */
ATP.ajaxLong = function(action, data, timeout, callback, errorCallback) {
    var self = this;
    data = data || {};
    data.ajax = action;
    data.csrf_token = this.getCsrfToken();

    $.ajax({
        url: this.ajaxUrl,
        method: 'POST',
        data: data,
        dataType: 'json',
        timeout: timeout || 120000
    }).done(function(response) {
        if (callback) callback(response);
    }).fail(function(xhr, status, error) {
        console.error('[ATP] AJAX long error:', action, status, error);
        if (errorCallback) {
            errorCallback(error, xhr);
        }
    });
};

/* ============================================
   FORMATTING UTILITIES
   ============================================ */

/**
 * Format bytes to human readable string
 * @param {number} bytes - Number of bytes
 * @param {number} decimals - Decimal places (default: 2)
 * @returns {string} Formatted string (e.g., "1.5 GB")
 */
ATP.formatBytes = function(bytes, decimals) {
    if (bytes === 0 || bytes === null || bytes === undefined) return '0 B';
    decimals = decimals !== undefined ? decimals : 2;

    var k = 1024;
    var sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
    var i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
};

/**
 * Format seconds to human readable duration
 * @param {number} seconds - Number of seconds
 * @returns {string} Formatted duration (e.g., "2h 30m")
 */
ATP.formatDuration = function(seconds) {
    if (!seconds || isNaN(seconds) || seconds <= 0) return '-';

    seconds = Math.floor(seconds);

    if (seconds < 60) {
        return seconds + 's';
    }
    if (seconds < 3600) {
        var m = Math.floor(seconds / 60);
        var s = seconds % 60;
        return m + 'm ' + s + 's';
    }
    if (seconds < 86400) {
        var h = Math.floor(seconds / 3600);
        var m = Math.floor((seconds % 3600) / 60);
        return h + 'h ' + m + 'm';
    }

    var d = Math.floor(seconds / 86400);
    var h = Math.floor((seconds % 86400) / 3600);
    return d + 'd ' + h + 'h';
};

/**
 * Format countdown timer
 * @param {number} seconds - Seconds remaining
 * @returns {string} Formatted countdown (e.g., "5m 30s")
 */
ATP.formatCountdown = function(seconds) {
    if (seconds <= 0) return 'Now';
    return this.formatDuration(seconds);
};

/**
 * Format timestamp to locale string
 * @param {number|string} timestamp - Unix timestamp or ISO string
 * @returns {string} Formatted date/time
 */
ATP.formatTimestamp = function(timestamp) {
    if (!timestamp) return '-';

    var date;
    if (typeof timestamp === 'number') {
        date = new Date(timestamp * 1000);
    } else {
        date = new Date(timestamp);
    }

    if (isNaN(date.getTime())) return '-';

    return date.toLocaleString();
};

/**
 * Format relative time (e.g., "5 minutes ago")
 * @param {number|string} timestamp - Unix timestamp or ISO string
 * @returns {string} Relative time string
 */
ATP.formatRelativeTime = function(timestamp) {
    if (!timestamp) return '-';

    var date;
    if (typeof timestamp === 'number') {
        date = new Date(timestamp * 1000);
    } else {
        date = new Date(timestamp);
    }

    if (isNaN(date.getTime())) return '-';

    var seconds = Math.floor((Date.now() - date.getTime()) / 1000);

    if (seconds < 60) return 'just now';
    if (seconds < 3600) return Math.floor(seconds / 60) + ' min ago';
    if (seconds < 86400) return Math.floor(seconds / 3600) + ' hours ago';
    if (seconds < 604800) return Math.floor(seconds / 86400) + ' days ago';

    return date.toLocaleDateString();
};

/* ============================================
   STRING UTILITIES
   ============================================ */

/**
 * Escape HTML entities to prevent XSS
 * @param {string} str - String to escape
 * @returns {string} Escaped string
 */
ATP.escapeHtml = function(str) {
    if (!str) return '';
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
};

/**
 * Truncate string with ellipsis
 * @param {string} str - String to truncate
 * @param {number} maxLength - Maximum length
 * @returns {string} Truncated string
 */
ATP.truncate = function(str, maxLength) {
    if (!str) return '';
    maxLength = maxLength || 50;
    if (str.length <= maxLength) return str;
    return str.substring(0, maxLength - 3) + '...';
};

/**
 * Get filename from path
 * @param {string} path - Full file path
 * @returns {string} Filename only
 */
ATP.getFilename = function(path) {
    if (!path) return '';
    return path.split('/').pop().split('\\').pop();
};

/* ============================================
   TAB MANAGEMENT
   ============================================ */

/**
 * Initialize tab switching
 * @param {string} tabSelector - Selector for tab elements
 * @param {string} panelPrefix - Prefix for panel IDs
 * @param {Function} onTabChange - Callback when tab changes
 */
ATP.initTabs = function(tabSelector, panelPrefix, onTabChange) {
    var self = this;
    tabSelector = tabSelector || '.atp-tab';
    panelPrefix = panelPrefix || '#panel-';

    $(tabSelector).click(function() {
        var tab = $(this).data('tab');

        // Update tab active state
        $(tabSelector).removeClass('active');
        $(this).addClass('active');

        // Update panel visibility
        $('.atp-panel').removeClass('active');
        $(panelPrefix + tab).addClass('active');

        self.currentTab = tab;

        if (onTabChange) {
            onTabChange(tab);
        }
    });
};

/* ============================================
   AUTO-REFRESH
   ============================================ */

/**
 * Start auto-refresh timer
 * @param {Function} refreshFunction - Function to call on refresh
 * @param {string} countdownSelector - Selector for countdown display
 */
ATP.startRefresh = function(refreshFunction, countdownSelector) {
    var self = this;
    countdownSelector = countdownSelector || '#refresh-countdown';

    this.stopRefresh();

    // Initial refresh
    if (refreshFunction) refreshFunction();

    this.countdown = this.refreshInterval / 1000;
    $(countdownSelector).text(this.countdown);

    this.refreshTimer = setInterval(function() {
        self.countdown--;
        $(countdownSelector).text(self.countdown);

        if (self.countdown <= 0) {
            self.countdown = self.refreshInterval / 1000;
            if (refreshFunction) refreshFunction();
        }
    }, 1000);
};

/**
 * Stop auto-refresh timer
 */
ATP.stopRefresh = function() {
    if (this.refreshTimer) {
        clearInterval(this.refreshTimer);
        this.refreshTimer = null;
    }
};

/* ============================================
   DIALOG HELPERS
   ============================================ */

/**
 * Show confirmation dialog using SweetAlert or fallback
 * @param {Object} options - Dialog options
 * @param {string} options.title - Dialog title
 * @param {string} options.text - Dialog message
 * @param {string} options.type - Dialog type (warning, info, success, error)
 * @param {Function} callback - Called with true/false
 */
ATP.confirm = function(options, callback) {
    if (typeof swal !== 'undefined') {
        swal({
            title: options.title || 'Confirm',
            text: options.text || 'Are you sure?',
            type: options.type || 'warning',
            showCancelButton: true,
            confirmButtonColor: options.type === 'warning' ? '#f44336' : '#e67e22'
        }, function(confirmed) {
            if (callback) callback(confirmed);
        });
    } else {
        var result = confirm(options.text || 'Are you sure?');
        if (callback) callback(result);
    }
};

/**
 * Show alert dialog using SweetAlert or fallback
 * @param {Object} options - Dialog options
 * @param {string} options.title - Dialog title
 * @param {string} options.text - Dialog message
 * @param {string} options.type - Dialog type (success, error, info, warning)
 */
ATP.alert = function(options) {
    if (typeof swal !== 'undefined') {
        swal({
            title: options.title || 'Alert',
            text: options.text || '',
            type: options.type || 'info'
        });
    } else {
        alert((options.title ? options.title + '\n\n' : '') + (options.text || ''));
    }
};

/**
 * Show loading dialog
 * @param {string} title - Loading title
 * @param {string} text - Loading message
 */
ATP.showLoading = function(title, text) {
    if (typeof swal !== 'undefined') {
        swal({
            title: title || 'Processing...',
            text: text || 'Please wait...',
            type: 'info',
            showConfirmButton: false
        });
    }
};

/**
 * Close any open dialog
 */
ATP.closeDialog = function() {
    if (typeof swal !== 'undefined') {
        swal.close();
    }
};

/* ============================================
   BUTTON STATE HELPERS
   ============================================ */

/**
 * Set button to loading state
 * @param {jQuery|string} button - Button element or selector
 * @param {string} loadingText - Text to show while loading
 */
ATP.setButtonLoading = function(button, loadingText) {
    var $btn = $(button);
    var $icon = $btn.find('i').first();
    var $text = $btn.find('span').first();

    $btn.prop('disabled', true);
    $btn.data('original-icon', $icon.attr('class'));
    $btn.data('original-text', $text.text());

    $icon.attr('class', 'fa fa-spinner fa-spin');
    if (loadingText) $text.text(loadingText);
};

/**
 * Reset button from loading state
 * @param {jQuery|string} button - Button element or selector
 * @param {boolean} success - Whether operation was successful
 * @param {string} resultText - Optional text to show briefly
 */
ATP.resetButton = function(button, success, resultText) {
    var $btn = $(button);
    var $icon = $btn.find('i').first();
    var $text = $btn.find('span').first();

    var originalIcon = $btn.data('original-icon');
    var originalText = $btn.data('original-text');

    // Show result briefly
    $icon.attr('class', success ? 'fa fa-check' : 'fa fa-times');
    if (resultText) $text.text(resultText);

    setTimeout(function() {
        $btn.prop('disabled', false);
        $icon.attr('class', originalIcon || 'fa fa-save');
        $text.text(originalText || 'Save');
    }, 1500);
};

/* ============================================
   EXPORT FOR CommonJS/AMD
   ============================================ */
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ATP;
} else if (typeof define === 'function' && define.amd) {
    define(function() { return ATP; });
}


</script>

]]>
</INLINE>
</FILE>

<!-- Python Daemon -->
<FILE Name="/usr/local/emhttp/plugins/atp_backup/atp_backup.py" Mode="0755">
<INLINE>
<![CDATA[
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ATP Backup - Python Daemon v2026.01.28
Smart backup solution for Unraid with local, remote SMB, WOL, and cloud support
Author: Tegenett
"""

import os
import sys
import time
import json
import sqlite3
import logging
import signal
import socket
import subprocess
import threading
import re
from pathlib import Path
from datetime import datetime, timedelta
from contextlib import contextmanager
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
from urllib.parse import parse_qs, urlparse

# ============================================
# CONFIGURATION
# ============================================

class Config:
    PLUGIN_NAME = "atp_backup"
    CONFIG_DIR = f"/boot/config/plugins/{PLUGIN_NAME}"
    DATA_DIR = f"/mnt/user/appdata/{PLUGIN_NAME}"
    DB_FILE = "atp_backup.db"
    SETTINGS_FILE = "settings.json"
    PID_FILE = f"/var/run/{PLUGIN_NAME}.pid"
    VERSION = "2026.01.30e"
    
    DEFAULTS = {
        "ENABLED": True,
        "SERVER_PORT": 39982,
        "LOG_LEVEL": "INFO",
        "LOG_MAX_LINES": 10000,
        "DISCORD_WEBHOOK_URL": "",
        "DISCORD_NOTIFY_START": True,
        "DISCORD_NOTIFY_SUCCESS": True,
        "DISCORD_NOTIFY_FAILURE": True,
        "DISCORD_DAILY_SUMMARY": False,
        "DISCORD_SUMMARY_HOUR": 20,
        "UNRAID_NOTIFICATIONS": True,
        "DEFAULT_BANDWIDTH_LIMIT": 0,
        "RSYNC_OPTIONS": "-avh --delete --stats --progress",
        "UD_MOUNT_TIMEOUT": 60,
        "WOL_WAIT_TIMEOUT": 120,
        "WOL_PING_INTERVAL": 5,
        "SMB_SETTLE_TIME": 10,
        "RETRY_ON_FAILURE": True,
        "RETRY_INTERVAL_MINUTES": 60,
        "RETRY_MAX_ATTEMPTS": 3,
        "HISTORY_RETENTION_DAYS": 90
    }
    
    C = DEFAULTS.copy()
    
    @classmethod
    def load(cls):
        """Load configuration from settings.json"""
        os.makedirs(cls.CONFIG_DIR, exist_ok=True)
        os.makedirs(cls.DATA_DIR, exist_ok=True)
        os.makedirs(os.path.join(cls.DATA_DIR, "logs"), exist_ok=True)
        
        path = os.path.join(cls.CONFIG_DIR, cls.SETTINGS_FILE)
        if os.path.exists(path):
            try:
                with open(path, 'r') as f:
                    loaded = json.load(f)
                    cls.C.update(loaded)
            except Exception as e:
                print(f"[Config] Load error: {e}")
        
        # Type conversions
        int_keys = ["SERVER_PORT", "LOG_MAX_LINES", "DISCORD_SUMMARY_HOUR", 
                    "DEFAULT_BANDWIDTH_LIMIT", "UD_MOUNT_TIMEOUT", 
                    "WOL_WAIT_TIMEOUT", "WOL_PING_INTERVAL", "SMB_SETTLE_TIME",
                    "RETRY_INTERVAL_MINUTES", "RETRY_MAX_ATTEMPTS"]
        for key in int_keys:
            try:
                cls.C[key] = int(cls.C.get(key, cls.DEFAULTS.get(key, 0)))
            except (ValueError, TypeError):
                cls.C[key] = cls.DEFAULTS.get(key, 0)
        
        # Boolean conversions
        bool_keys = ["ENABLED", "DISCORD_DAILY_SUMMARY", "UNRAID_NOTIFICATIONS", "RETRY_ON_FAILURE"]
        for key in bool_keys:
            val = cls.C.get(key, cls.DEFAULTS.get(key, False))
            if isinstance(val, str):
                cls.C[key] = val.lower() in ('true', '1', 'yes')
            else:
                cls.C[key] = bool(val)
    
    @classmethod
    def save(cls):
        """Save current configuration to settings.json"""
        path = os.path.join(cls.CONFIG_DIR, cls.SETTINGS_FILE)
        try:
            with open(path, 'w') as f:
                json.dump(cls.C, f, indent=2)
            return True, "Settings saved"
        except Exception as e:
            return False, str(e)

Config.load()

# ============================================
# LOGGING
# ============================================

from logging.handlers import RotatingFileHandler

LOG_FILE = os.path.join(Config.DATA_DIR, "logs", f"{Config.PLUGIN_NAME}.log")
os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)

_log_level_str = Config.C.get('LOG_LEVEL', 'INFO').upper()
_log_level = getattr(logging, _log_level_str, logging.INFO)

# Log rotation settings from config
_log_max_size = int(Config.C.get('LOG_MAX_SIZE_KB', 5000)) * 1024  # Default 5MB
_log_keep_count = int(Config.C.get('LOG_KEEP_COUNT', 5))

# Create logger - use unique name and prevent propagation to root
logger = logging.getLogger(f"{Config.PLUGIN_NAME}_daemon")

# Only add handlers if not already added (prevents duplicates on reload)
if not logger.handlers:
    logger.setLevel(_log_level)
    logger.propagate = False  # Critical: prevents duplicate logs from root logger
    
    # Rotating file handler - automatically rotates when file exceeds max size
    file_handler = RotatingFileHandler(
        LOG_FILE, 
        maxBytes=_log_max_size, 
        backupCount=_log_keep_count
    )
    file_handler.setLevel(_log_level)
    file_handler.setFormatter(logging.Formatter('%(asctime)s [%(levelname)s] %(message)s', '%Y-%m-%d %H:%M:%S'))
    logger.addHandler(file_handler)

# ============================================
# LOG MANAGER
# ============================================

class LogManager:
    """Manage log files and rotation"""
    
    @staticmethod
    def get_log_files():
        """Get list of all log files with sizes"""
        log_dir = os.path.dirname(LOG_FILE)
        log_files = []
        
        if os.path.exists(log_dir):
            for f in os.listdir(log_dir):
                if f.startswith(Config.PLUGIN_NAME):
                    path = os.path.join(log_dir, f)
                    size = os.path.getsize(path)
                    log_files.append({'name': f, 'size': size, 'path': path})
        
        return sorted(log_files, key=lambda x: x['name'])
    
    @staticmethod
    def get_total_log_size():
        """Get total size of all log files"""
        return sum(f['size'] for f in LogManager.get_log_files())
    
    @staticmethod
    def rotate_now():
        """Force immediate log rotation"""
        for handler in logger.handlers:
            if isinstance(handler, RotatingFileHandler):
                handler.doRollover()
                logger.info("[LogManager] Log rotated manually")
                return True
        return False
    
    @staticmethod
    def clear_old_logs():
        """Delete all rotated log files (keep only current)"""
        log_dir = os.path.dirname(LOG_FILE)
        deleted = 0
        
        for f in os.listdir(log_dir):
            if f.startswith(Config.PLUGIN_NAME) and f != os.path.basename(LOG_FILE):
                try:
                    os.remove(os.path.join(log_dir, f))
                    deleted += 1
                except Exception as e:
                    logger.warning(f"[LogManager] Failed to delete {f}: {e}")
        
        logger.info(f"[LogManager] Cleared {deleted} old log files")
        return deleted

START_TIME = time.time()

# ============================================
# DATABASE WITH MIGRATION
# ============================================

class Database:
    # Schema version for migrations
    SCHEMA_VERSION = 3
    
    def __init__(self):
        self.db_path = os.path.join(Config.DATA_DIR, Config.DB_FILE)
        self.lock = threading.RLock()
        self._init_db()
        self._migrate_db()
    
    def _init_db(self):
        """Initialize database tables"""
        logger.info("[Database] Initializing database...")
        with self._conn() as conn:
            conn.executescript('''
                CREATE TABLE IF NOT EXISTS backup_jobs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    enabled INTEGER DEFAULT 1,
                    job_type TEXT NOT NULL,
                    source_path TEXT NOT NULL,
                    dest_path TEXT,
                    remote_host TEXT,
                    remote_share TEXT,
                    remote_mount_point TEXT,
                    remote_user TEXT,
                    remote_pass TEXT,
                    mac_address TEXT,
                    use_wol INTEGER DEFAULT 0,
                    shutdown_after INTEGER DEFAULT 0,
                    schedule_type TEXT DEFAULT 'disabled',
                    schedule_hour INTEGER DEFAULT 0,
                    schedule_minute INTEGER DEFAULT 0,
                    schedule_day INTEGER DEFAULT 0,
                    schedule_cron TEXT,
                    bandwidth_limit INTEGER DEFAULT 0,
                    exclude_patterns TEXT,
                    retention_count INTEGER DEFAULT 0,
                    retention_days INTEGER DEFAULT 0,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
                
                CREATE TABLE IF NOT EXISTS backup_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    job_id INTEGER NOT NULL,
                    job_name TEXT NOT NULL,
                    status TEXT NOT NULL,
                    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    finished_at TIMESTAMP,
                    bytes_transferred INTEGER DEFAULT 0,
                    files_transferred INTEGER DEFAULT 0,
                    duration_seconds INTEGER DEFAULT 0,
                    transfer_speed_mbps REAL DEFAULT 0,
                    error_message TEXT,
                    dry_run INTEGER DEFAULT 0,
                    log_output TEXT,
                    FOREIGN KEY (job_id) REFERENCES backup_jobs(id) ON DELETE CASCADE
                );
                
                CREATE TABLE IF NOT EXISTS daily_stats (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date TEXT UNIQUE NOT NULL,
                    total_jobs_run INTEGER DEFAULT 0,
                    successful_jobs INTEGER DEFAULT 0,
                    failed_jobs INTEGER DEFAULT 0,
                    total_bytes INTEGER DEFAULT 0,
                    total_files INTEGER DEFAULT 0,
                    total_duration INTEGER DEFAULT 0
                );
                
                CREATE TABLE IF NOT EXISTS schema_version (
                    version INTEGER PRIMARY KEY
                );
                
                CREATE INDEX IF NOT EXISTS idx_history_job ON backup_history(job_id);
                CREATE INDEX IF NOT EXISTS idx_history_status ON backup_history(status);
                CREATE INDEX IF NOT EXISTS idx_history_started ON backup_history(started_at);
                CREATE INDEX IF NOT EXISTS idx_stats_date ON daily_stats(date);
            ''')
        logger.info("[Database] Initialization complete")
    
    def _migrate_db(self):
        """Run database migrations"""
        with self._conn() as conn:
            # Get current schema version
            try:
                row = conn.execute("SELECT version FROM schema_version ORDER BY version DESC LIMIT 1").fetchone()
                current_version = row['version'] if row else 0
            except:
                current_version = 0
            
            logger.info(f"[Database] Current schema version: {current_version}, target: {self.SCHEMA_VERSION}")
            
            if current_version < 2:
                # Migration to v2: Add retry columns
                logger.info("[Database] Migrating to schema v2...")
                
                # Check if columns exist before adding
                columns = [row['name'] for row in conn.execute("PRAGMA table_info(backup_jobs)").fetchall()]
                
                if 'retry_on_failure' not in columns:
                    conn.execute("ALTER TABLE backup_jobs ADD COLUMN retry_on_failure INTEGER DEFAULT 1")
                    logger.info("[Database] Added retry_on_failure column")
                
                if 'retry_count' not in columns:
                    conn.execute("ALTER TABLE backup_jobs ADD COLUMN retry_count INTEGER DEFAULT 0")
                    logger.info("[Database] Added retry_count column")
                
                if 'last_retry_at' not in columns:
                    conn.execute("ALTER TABLE backup_jobs ADD COLUMN last_retry_at TIMESTAMP")
                    logger.info("[Database] Added last_retry_at column")
                
                # Check history table
                history_columns = [row['name'] for row in conn.execute("PRAGMA table_info(backup_history)").fetchall()]
                
                if 'is_retry' not in history_columns:
                    conn.execute("ALTER TABLE backup_history ADD COLUMN is_retry INTEGER DEFAULT 0")
                    logger.info("[Database] Added is_retry column to history")
                
                # Update schema version
                conn.execute("INSERT OR REPLACE INTO schema_version (version) VALUES (?)", (2,))
                logger.info("[Database] Migration to v2 complete")
            
            if current_version < 3:
                # Migration to v3: Add pre/post script columns
                logger.info("[Database] Migrating to schema v3...")
                
                columns = [row['name'] for row in conn.execute("PRAGMA table_info(backup_jobs)").fetchall()]
                
                if 'pre_script' not in columns:
                    conn.execute("ALTER TABLE backup_jobs ADD COLUMN pre_script TEXT")
                    logger.info("[Database] Added pre_script column")
                
                if 'post_script' not in columns:
                    conn.execute("ALTER TABLE backup_jobs ADD COLUMN post_script TEXT")
                    logger.info("[Database] Added post_script column")
                
                conn.execute("INSERT OR REPLACE INTO schema_version (version) VALUES (?)", (3,))
                logger.info("[Database] Migration to v3 complete")
    
    @contextmanager
    def _conn(self):
        """Thread-safe database connection context manager"""
        acquired = self.lock.acquire(timeout=30)
        if not acquired:
            logger.error("[Database] Could not acquire lock within 30 seconds!")
            raise Exception("Database lock timeout")
        try:
            conn = sqlite3.connect(self.db_path, timeout=30, isolation_level='DEFERRED')
            conn.row_factory = sqlite3.Row
            conn.execute("PRAGMA journal_mode=WAL")
            conn.execute("PRAGMA busy_timeout=30000")
            conn.execute("PRAGMA foreign_keys=ON")
            try:
                yield conn
                conn.commit()
            except Exception as e:
                logger.error(f"[Database] Rolling back due to error: {e}")
                conn.rollback()
                raise
            finally:
                conn.close()
        finally:
            self.lock.release()
    
    # ---- Job CRUD ----
    
    def get_jobs(self):
        with self._conn() as conn:
            rows = conn.execute("SELECT * FROM backup_jobs ORDER BY name").fetchall()
            return [dict(row) for row in rows]
    
    def get_enabled_jobs(self):
        with self._conn() as conn:
            rows = conn.execute("SELECT * FROM backup_jobs WHERE enabled = 1 ORDER BY name").fetchall()
            return [dict(row) for row in rows]
    
    def get_failed_jobs_for_retry(self):
        """Get jobs that failed and need retry"""
        with self._conn() as conn:
            max_retries = int(Config.C.get("RETRY_MAX_ATTEMPTS", 3) or 3)
            retry_interval = int(Config.C.get("RETRY_INTERVAL_MINUTES", 60) or 60)
            
            rows = conn.execute('''
                SELECT j.* FROM backup_jobs j
                INNER JOIN (
                    SELECT job_id, MAX(id) as last_id 
                    FROM backup_history 
                    GROUP BY job_id
                ) h ON j.id = h.job_id
                INNER JOIN backup_history bh ON bh.id = h.last_id
                WHERE j.enabled = 1 
                AND j.retry_on_failure = 1
                AND bh.status = 'failed'
                AND j.retry_count < ?
                AND (j.last_retry_at IS NULL OR 
                     datetime(j.last_retry_at, '+' || ? || ' minutes') <= datetime('now'))
            ''', (max_retries, retry_interval)).fetchall()
            return [dict(row) for row in rows]
    
    def get_job(self, job_id):
        with self._conn() as conn:
            row = conn.execute("SELECT * FROM backup_jobs WHERE id = ?", (job_id,)).fetchone()
            return dict(row) if row else None
    
    def create_job(self, job_data):
        logger.info(f"[Database] Creating job: {job_data.get('name')}")
        with self._conn() as conn:
            cursor = conn.execute('''
                INSERT INTO backup_jobs (name, job_type, source_path, dest_path, 
                    remote_host, remote_share, remote_mount_point, remote_user, remote_pass,
                    mac_address, use_wol, shutdown_after, schedule_type, 
                    schedule_hour, schedule_minute, schedule_day, schedule_cron,
                    bandwidth_limit, exclude_patterns, retention_count, retention_days, 
                    enabled, retry_on_failure, pre_script, post_script)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                job_data.get('name'),
                job_data.get('job_type', 'local'),
                job_data.get('source_path'),
                job_data.get('dest_path'),
                job_data.get('remote_host'),
                job_data.get('remote_share'),
                job_data.get('remote_mount_point'),
                job_data.get('remote_user'),
                job_data.get('remote_pass'),
                job_data.get('mac_address'),
                int(job_data.get('use_wol', 0)),
                int(job_data.get('shutdown_after', 0)),
                job_data.get('schedule_type', 'disabled'),
                int(job_data.get('schedule_hour', 0)),
                int(job_data.get('schedule_minute', 0)),
                int(job_data.get('schedule_day', 0)),
                job_data.get('schedule_cron'),
                int(job_data.get('bandwidth_limit', 0)),
                job_data.get('exclude_patterns'),
                int(job_data.get('retention_count', 0)),
                int(job_data.get('retention_days', 0)),
                int(job_data.get('enabled', 1)),
                int(job_data.get('retry_on_failure', 1)),
                job_data.get('pre_script'),
                job_data.get('post_script')
            ))
            return cursor.lastrowid
    
    def update_job(self, job_id, job_data):
        logger.info(f"[Database] Updating job ID: {job_id}")
        with self._conn() as conn:
            conn.execute('''
                UPDATE backup_jobs SET
                    name = ?, job_type = ?, source_path = ?, dest_path = ?,
                    remote_host = ?, remote_share = ?, remote_mount_point = ?,
                    remote_user = ?, remote_pass = ?,
                    mac_address = ?, use_wol = ?, shutdown_after = ?, schedule_type = ?,
                    schedule_hour = ?, schedule_minute = ?, schedule_day = ?, schedule_cron = ?,
                    bandwidth_limit = ?, exclude_patterns = ?, retention_count = ?, retention_days = ?,
                    enabled = ?, retry_on_failure = ?, pre_script = ?, post_script = ?,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            ''', (
                job_data.get('name'),
                job_data.get('job_type'),
                job_data.get('source_path'),
                job_data.get('dest_path'),
                job_data.get('remote_host'),
                job_data.get('remote_share'),
                job_data.get('remote_mount_point'),
                job_data.get('remote_user'),
                job_data.get('remote_pass'),
                job_data.get('mac_address'),
                int(job_data.get('use_wol', 0)),
                int(job_data.get('shutdown_after', 0)),
                job_data.get('schedule_type'),
                int(job_data.get('schedule_hour', 0)),
                int(job_data.get('schedule_minute', 0)),
                int(job_data.get('schedule_day', 0)),
                job_data.get('schedule_cron'),
                int(job_data.get('bandwidth_limit', 0)),
                job_data.get('exclude_patterns'),
                int(job_data.get('retention_count', 0)),
                int(job_data.get('retention_days', 0)),
                int(job_data.get('enabled', 1)),
                int(job_data.get('retry_on_failure', 1)),
                job_data.get('pre_script'),
                job_data.get('post_script'),
                job_id
            ))
    
    def toggle_job(self, job_id, enabled):
        """Toggle job enabled/disabled status"""
        logger.info(f"[Database] Toggling job ID {job_id} to enabled={enabled}")
        with self._conn() as conn:
            conn.execute("UPDATE backup_jobs SET enabled = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?", 
                        (int(enabled), job_id))
    
    def reset_retry_count(self, job_id):
        """Reset retry count after successful backup"""
        with self._conn() as conn:
            conn.execute("UPDATE backup_jobs SET retry_count = 0, last_retry_at = NULL WHERE id = ?", (job_id,))
    
    def increment_retry_count(self, job_id):
        """Increment retry count after failed retry"""
        with self._conn() as conn:
            conn.execute("""
                UPDATE backup_jobs 
                SET retry_count = retry_count + 1, last_retry_at = CURRENT_TIMESTAMP 
                WHERE id = ?
            """, (job_id,))
    
    def delete_job(self, job_id):
        logger.info(f"[Database] Deleting job ID: {job_id}")
        with self._conn() as conn:
            conn.execute("DELETE FROM backup_history WHERE job_id = ?", (job_id,))
            conn.execute("DELETE FROM backup_jobs WHERE id = ?", (job_id,))
    
    # ---- History ----
    
    def add_history(self, job_id, job_name, status, dry_run=False, is_retry=False):
        with self._conn() as conn:
            cursor = conn.execute('''
                INSERT INTO backup_history (job_id, job_name, status, dry_run, is_retry)
                VALUES (?, ?, ?, ?, ?)
            ''', (job_id, job_name, status, 1 if dry_run else 0, 1 if is_retry else 0))
            return cursor.lastrowid
    
    def update_history(self, history_id, status, bytes_transferred=0, files_transferred=0,
                       duration_seconds=0, transfer_speed_mbps=0, error_message=None, log_output=None):
        with self._conn() as conn:
            conn.execute('''
                UPDATE backup_history SET
                    status = ?, finished_at = CURRENT_TIMESTAMP,
                    bytes_transferred = ?, files_transferred = ?,
                    duration_seconds = ?, transfer_speed_mbps = ?,
                    error_message = ?, log_output = ?
                WHERE id = ?
            ''', (status, bytes_transferred, files_transferred, duration_seconds,
                  transfer_speed_mbps, error_message, log_output, history_id))
    
    def get_history(self, limit=100, job_id=None, status=None):
        with self._conn() as conn:
            query = "SELECT * FROM backup_history WHERE 1=1"
            params = []
            
            if job_id:
                query += " AND job_id = ?"
                params.append(job_id)
            if status:
                query += " AND status = ?"
                params.append(status)
            
            query += " ORDER BY started_at DESC LIMIT ?"
            params.append(limit)
            
            rows = conn.execute(query, params).fetchall()
            return [dict(row) for row in rows]
    
    def get_last_run(self, job_id):
        with self._conn() as conn:
            row = conn.execute('''
                SELECT * FROM backup_history 
                WHERE job_id = ?
                ORDER BY started_at DESC LIMIT 1
            ''', (job_id,)).fetchone()
            return dict(row) if row else None
    
    # ---- Statistics ----
    
    def update_daily_stats(self, bytes_transferred, files_transferred, duration, success):
        today = datetime.now().strftime('%Y-%m-%d')
        with self._conn() as conn:
            conn.execute('''
                INSERT INTO daily_stats (date, total_jobs_run, successful_jobs, failed_jobs,
                    total_bytes, total_files, total_duration)
                VALUES (?, 1, ?, ?, ?, ?, ?)
                ON CONFLICT(date) DO UPDATE SET
                    total_jobs_run = total_jobs_run + 1,
                    successful_jobs = successful_jobs + ?,
                    failed_jobs = failed_jobs + ?,
                    total_bytes = total_bytes + ?,
                    total_files = total_files + ?,
                    total_duration = total_duration + ?
            ''', (today, 1 if success else 0, 0 if success else 1, bytes_transferred,
                  files_transferred, duration,
                  1 if success else 0, 0 if success else 1, bytes_transferred,
                  files_transferred, duration))
    
    def get_stats(self, days=30):
        with self._conn() as conn:
            rows = conn.execute('''
                SELECT * FROM daily_stats 
                WHERE date >= date('now', ?)
                ORDER BY date DESC
            ''', (f'-{days} days',)).fetchall()
            return [dict(row) for row in rows]
    
    def get_totals(self):
        with self._conn() as conn:
            row = conn.execute('''
                SELECT 
                    COUNT(*) as total_runs,
                    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as successful,
                    SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed,
                    SUM(bytes_transferred) as total_bytes,
                    SUM(files_transferred) as total_files,
                    SUM(duration_seconds) as total_duration
                FROM backup_history
            ''').fetchone()
            return dict(row) if row else {}
    
    # ---- Database Management ----
    
    def clear_history(self):
        """Delete all backup history records"""
        logger.info("[Database] Clearing all backup history")
        with self._conn() as conn:
            conn.execute("DELETE FROM backup_history")
            logger.info("[Database] History cleared")
    
    def reset_statistics(self):
        """Reset all daily statistics"""
        logger.info("[Database] Resetting all statistics")
        with self._conn() as conn:
            conn.execute("DELETE FROM daily_stats")
            logger.info("[Database] Statistics reset")
    
    def reset_database(self):
        """Full database reset - clears history and statistics, keeps jobs"""
        logger.info("[Database] Full database reset starting")
        with self._conn() as conn:
            conn.execute("DELETE FROM backup_history")
            conn.execute("DELETE FROM daily_stats")
            # Reset retry counts on all jobs
            conn.execute("UPDATE backup_jobs SET retry_count = 0, last_retry_at = NULL")
            logger.info("[Database] Full database reset complete")

DB = Database()

# ============================================
# WAKE ON LAN
# ============================================

class WakeOnLan:
    @staticmethod
    def send_magic_packet(mac_address, broadcast_ip='255.255.255.255', port=9):
        try:
            mac = mac_address.replace(':', '').replace('-', '').replace('.', '').lower()
            if len(mac) != 12:
                raise ValueError(f"Invalid MAC address: {mac_address}")
            
            try:
                int(mac, 16)
            except ValueError:
                raise ValueError(f"Invalid MAC address (not hex): {mac_address}")
            
            mac_bytes = bytes.fromhex(mac)
            packet = b'\xff' * 6 + mac_bytes * 16
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
            sock.sendto(packet, (broadcast_ip, port))
            sock.close()
            
            logger.info(f"[WOL] Sent magic packet to {mac_address}")
            return True, "Magic packet sent"
        except Exception as e:
            logger.error(f"[WOL] Failed to send magic packet: {e}")
            return False, str(e)
    
    @staticmethod
    def wait_for_host(host, timeout=120, interval=5):
        logger.info(f"[WOL] Waiting for {host} to come online (timeout: {timeout}s)")
        start = time.time()
        while time.time() - start < timeout:
            if WakeOnLan.ping(host):
                elapsed = int(time.time() - start)
                logger.info(f"[WOL] {host} is online after {elapsed}s")
                return True, elapsed
            time.sleep(interval)
        logger.warning(f"[WOL] Timeout waiting for {host}")
        return False, timeout
    
    @staticmethod
    def ping(host, timeout=2):
        try:
            result = subprocess.run(
                ['ping', '-c', '1', '-W', str(timeout), host],
                capture_output=True, timeout=timeout+2
            )
            return result.returncode == 0
        except:
            return False

# ============================================
# REMOTE SHUTDOWN
# ============================================

class RemoteShutdown:
    @staticmethod
    def shutdown_windows(host, username, password, timeout_seconds=30, force=True, message="Backup completed"):
        try:
            cmd = ['net', 'rpc', 'shutdown', '-I', host, '-U', f'{username}%{password}']
            
            if timeout_seconds > 0:
                cmd.extend(['-t', str(timeout_seconds)])
            
            if force:
                cmd.append('-f')
            
            if message:
                cmd.extend(['-C', message])
            
            logger.info(f"[RemoteShutdown] Sending shutdown to {host}")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                logger.info(f"[RemoteShutdown] Shutdown command sent successfully to {host}")
                return True, "Shutdown command sent"
            else:
                error = result.stderr.strip() or result.stdout.strip() or f"Exit code {result.returncode}"
                logger.error(f"[RemoteShutdown] Failed - {error}")
                return False, error
        except subprocess.TimeoutExpired:
            return False, "Command timed out"
        except FileNotFoundError:
            return False, "Samba net command not found"
        except Exception as e:
            return False, str(e)

# ============================================
# MOUNT MANAGER
# ============================================

class MountManager:
    RC_PATHS = [
        '/usr/local/sbin/rc.unassigned',
        '/var/local/overlay/usr/local/sbin/rc.unassigned'
    ]
    
    @classmethod
    def get_rc_path(cls):
        for path in cls.RC_PATHS:
            if os.path.exists(path) and os.access(path, os.X_OK):
                return path
        return None
    
    @classmethod
    def is_ud_available(cls):
        return cls.get_rc_path() is not None
    
    @classmethod
    def mount(cls, share_name, timeout=60):
        rc_path = cls.get_rc_path()
        if not rc_path:
            return False, "Unassigned Devices plugin not installed"
        
        try:
            logger.info(f"[MountManager] Mounting {share_name}")
            result = subprocess.run(
                [rc_path, 'mount', share_name],
                capture_output=True, text=True, timeout=timeout
            )
            
            output = (result.stdout + result.stderr).lower()
            
            if result.returncode == 0 or 'success' in output:
                logger.info(f"[MountManager] Mounted {share_name}")
                return True, "Mounted successfully"
            else:
                error = result.stderr.strip() or result.stdout.strip() or "Mount failed"
                logger.error(f"[MountManager] Mount failed - {error}")
                return False, error
        except subprocess.TimeoutExpired:
            return False, f"Mount timed out after {timeout}s"
        except Exception as e:
            return False, str(e)
    
    @classmethod
    def unmount(cls, share_name, timeout=30):
        rc_path = cls.get_rc_path()
        if not rc_path:
            return False, "Unassigned Devices plugin not installed"
        
        try:
            logger.info(f"[MountManager] Unmounting {share_name}")
            result = subprocess.run(
                [rc_path, 'umount', share_name],
                capture_output=True, text=True, timeout=timeout
            )
            
            output = (result.stdout + result.stderr).lower()
            
            if result.returncode == 0 or 'success' in output:
                logger.info(f"[MountManager] Unmounted {share_name}")
                return True, "Unmounted successfully"
            else:
                error = result.stderr.strip() or result.stdout.strip() or "Unmount failed"
                logger.error(f"[MountManager] Unmount failed - {error}")
                return False, error
        except Exception as e:
            return False, str(e)
    
    @classmethod
    def is_mounted(cls, mount_point):
        try:
            result = subprocess.run(
                ['mountpoint', '-q', mount_point],
                capture_output=True, timeout=5
            )
            return result.returncode == 0
        except:
            return False

# ============================================
# NOTIFICATION MANAGER
# ============================================

class NotifyManager:
    COLORS = {
        "blue": 3447003,
        "green": 5763719,
        "red": 15548997,
        "orange": 15105570,
        "grey": 9807270
    }
    
    @classmethod
    def unraid_notify(cls, subject, description, importance="normal"):
        if not Config.C.get("UNRAID_NOTIFICATIONS", True):
            return True
        
        try:
            cmd = [
                '/usr/local/emhttp/webGui/scripts/notify',
                '-e', 'ATP Backup',
                '-s', subject,
                '-d', description,
                '-i', importance
            ]
            subprocess.run(cmd, capture_output=True, timeout=10)
            logger.debug(f"[Notify] Unraid notification sent: {subject}")
            return True
        except Exception as e:
            logger.error(f"[Notify] Unraid notification failed - {e}")
            return False
    
    @classmethod
    def discord_notify(cls, title, description, color="blue", fields=None, footer=None):
        url = Config.C.get("DISCORD_WEBHOOK_URL", "")
        if not url:
            logger.debug("[Notify] Discord webhook not configured")
            return True
        
        try:
            import urllib.request
            import ssl
            
            embed = {
                "title": title,
                "description": description,
                "color": cls.COLORS.get(color, cls.COLORS["grey"]),
                "footer": {"text": footer or f"ATP Backup v{Config.VERSION}"},
                "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S.000Z")
            }
            
            if fields:
                embed["fields"] = fields
            
            data = json.dumps({"embeds": [embed]}).encode()
            
            req = urllib.request.Request(
                url,
                data=data,
                headers={
                    'Content-Type': 'application/json',
                    'User-Agent': f'AtpBackup/{Config.VERSION}'
                }
            )
            
            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            
            with urllib.request.urlopen(req, timeout=10, context=ctx) as response:
                pass
            
            logger.info(f"[Notify] Discord notification sent: {title}")
            return True
        except Exception as e:
            logger.error(f"[Notify] Discord notification failed - {e}")
            return False
    
    @classmethod
    def send_daily_summary(cls):
        if not Config.C.get("DISCORD_DAILY_SUMMARY", False):
            return
        
        url = Config.C.get("DISCORD_WEBHOOK_URL", "")
        if not url:
            return
        
        today = datetime.now().strftime('%Y-%m-%d')
        stats = DB.get_stats(1)
        
        if not stats:
            return
        
        stat = stats[0]
        total = stat.get('total_jobs_run', 0)
        success = stat.get('successful_jobs', 0)
        failed = stat.get('failed_jobs', 0)
        total_bytes = stat.get('total_bytes', 0)
        
        gb = total_bytes / (1024**3) if total_bytes else 0
        
        color = "green" if failed == 0 else ("orange" if success > 0 else "red")
        
        cls.discord_notify(
            f" Daily Summary - {today}",
            f"Total jobs: {total}\nSuccessful: {success}\nFailed: {failed}",
            color,
            [
                {"name": "Data Transferred", "value": f"{gb:.2f} GB", "inline": True},
                {"name": "Success Rate", "value": f"{(success/max(total,1))*100:.0f}%", "inline": True}
            ]
        )

# ============================================
# BACKUP ENGINE
# ============================================

class BackupEngine:
    current_job = None
    current_history_id = None
    current_progress = {}
    abort_flag = False
    _lock = threading.Lock()
    
    @classmethod
    def is_running(cls):
        with cls._lock:
            return cls.current_job is not None
    
    @classmethod
    def get_status(cls):
        with cls._lock:
            if cls.current_job:
                return {
                    'running': True,
                    'job_id': cls.current_job.get('id'),
                    'job_name': cls.current_job.get('name'),
                    'progress': cls.current_progress.copy()
                }
            return {'running': False}
    
    @classmethod
    def abort(cls):
        cls.abort_flag = True
        logger.warning("[BackupEngine] Abort requested")
    
    @staticmethod
    def _format_size(bytes_val):
        """Format bytes to human readable string"""
        if bytes_val < 1024:
            return f"{bytes_val} B"
        elif bytes_val < 1024 * 1024:
            return f"{bytes_val / 1024:.1f} KB"
        elif bytes_val < 1024 * 1024 * 1024:
            return f"{bytes_val / (1024 * 1024):.2f} MB"
        else:
            return f"{bytes_val / (1024 * 1024 * 1024):.2f} GB"
    
    @staticmethod
    def _format_speed(bytes_per_sec):
        """Format speed to human readable string"""
        if bytes_per_sec < 1024:
            return f"{bytes_per_sec:.0f} B/s"
        elif bytes_per_sec < 1024 * 1024:
            return f"{bytes_per_sec / 1024:.1f} KB/s"
        else:
            return f"{bytes_per_sec / (1024 * 1024):.1f} MB/s"
    
    @classmethod
    def _run_script(cls, script_path, script_type):
        """Run a pre/post backup script"""
        if not script_path:
            return True, None
        
        if not os.path.exists(script_path):
            return False, f"Script not found: {script_path}"
        
        if not os.access(script_path, os.X_OK):
            # Try to make it executable
            try:
                os.chmod(script_path, 0o755)
            except:
                return False, f"Script not executable: {script_path}"
        
        logger.info(f"[BackupEngine] Running {script_type} script: {script_path}")
        
        try:
            result = subprocess.run(
                [script_path],
                capture_output=True,
                text=True,
                timeout=3600,  # 1 hour timeout
                cwd=os.path.dirname(script_path)
            )
            
            if result.returncode == 0:
                logger.info(f"[BackupEngine] {script_type} script completed successfully")
                return True, None
            else:
                error = result.stderr or result.stdout or f"Exit code {result.returncode}"
                logger.error(f"[BackupEngine] {script_type} script failed: {error}")
                return False, error
                
        except subprocess.TimeoutExpired:
            return False, "Script timed out after 1 hour"
        except Exception as e:
            return False, str(e)
    
    @classmethod
    def run_job(cls, job, dry_run=False, is_retry=False):
        with cls._lock:
            if cls.current_job:
                logger.warning("[BackupEngine] Cannot start job - another job is running")
                return False, "Another backup is already running"
            cls.current_job = job
            cls.current_progress = {'phase': 'starting', 'percent': 0}
            cls.abort_flag = False
        
        job_id = job['id']
        job_name = job['name']
        job_type = job['job_type']
        
        logger.info("=" * 60)
        logger.info(f"[BackupEngine] Starting job: {job_name}")
        logger.info(f"[BackupEngine] Type: {job_type}, Dry run: {dry_run}, Retry: {is_retry}")
        logger.info("=" * 60)
        
        history_id = DB.add_history(job_id, job_name, 'running', dry_run, is_retry)
        cls.current_history_id = history_id
        
        retry_text = " (Retry)" if is_retry else ""
        
        # Notify start if enabled
        if Config.C.get("DISCORD_NOTIFY_START", True):
            NotifyManager.discord_notify(
                f" Backup Started{retry_text}: {job_name}",
                f"Type: {job_type}\nDry run: {'Yes' if dry_run else 'No'}",
                "blue"
            )
        
        start_time = time.time()
        bytes_transferred = 0
        files_transferred = 0
        error_message = None
        log_output = ""
        success = False
        
        try:
            # Run pre-backup script if configured
            pre_script = job.get('pre_script')
            if pre_script and not dry_run:
                cls.current_progress['phase'] = 'pre-script'
                script_ok, script_error = cls._run_script(pre_script, 'pre-backup')
                if not script_ok:
                    error_message = f"Pre-backup script failed: {script_error}"
                    logger.error(f"[BackupEngine] {error_message}")
                    raise Exception(error_message)
            
            cls.current_progress['phase'] = 'running'
            
            if job_type == 'local':
                success, bytes_transferred, files_transferred, error_message, log_output = cls._run_local(job, dry_run)
            elif job_type == 'remote_smb':
                success, bytes_transferred, files_transferred, error_message, log_output = cls._run_remote_smb(job, dry_run)
            elif job_type == 'remote_smb_wol':
                success, bytes_transferred, files_transferred, error_message, log_output = cls._run_remote_smb_wol(job, dry_run)
            else:
                error_message = f"Unknown job type: {job_type}"
                logger.error(f"[BackupEngine] {error_message}")
            
            # Run post-backup script if configured and backup succeeded
            post_script = job.get('post_script')
            if post_script and not dry_run and success:
                cls.current_progress['phase'] = 'post-script'
                script_ok, script_error = cls._run_script(post_script, 'post-backup')
                if not script_ok:
                    logger.warning(f"[BackupEngine] Post-backup script failed: {script_error}")
                    # Don't fail the whole job for post-script failure
                    
        except Exception as e:
            error_message = str(e)
            logger.exception(f"[BackupEngine] Exception in job '{job_name}'")
        
        duration = int(time.time() - start_time)
        
        # Calculate speed in bytes/second, store as float for flexibility
        speed_bytes_per_sec = bytes_transferred / max(duration, 1)
        
        status = 'completed' if success else 'failed'
        DB.update_history(
            history_id, status, bytes_transferred, files_transferred,
            duration, speed_bytes_per_sec, error_message, log_output
        )
        
        if not dry_run:
            DB.update_daily_stats(bytes_transferred, files_transferred, duration, success)
        
        # Handle retry logic
        if success:
            DB.reset_retry_count(job_id)
        elif not dry_run and job.get('retry_on_failure', 1):
            DB.increment_retry_count(job_id)
        
        # Format size and speed for logging and notifications
        size_str = cls._format_size(bytes_transferred)
        speed_str = cls._format_speed(speed_bytes_per_sec)
        
        if success:
            logger.info(f"[BackupEngine] Job completed: {size_str} in {duration}s ({speed_str})")
            
            # Notify success if enabled
            if Config.C.get("DISCORD_NOTIFY_SUCCESS", True):
                NotifyManager.discord_notify(
                    f" Backup Completed{retry_text}: {job_name}",
                    f"Duration: {duration}s\nTransferred: {size_str}" + (" (dry run)" if dry_run else ""),
                    "green",
                    [
                        {"name": "Files", "value": str(files_transferred), "inline": True},
                        {"name": "Speed", "value": speed_str, "inline": True}
                    ]
                )
            NotifyManager.unraid_notify(f"Backup OK: {job_name}", f"Transferred {size_str} in {duration}s")
        else:
            logger.error(f"[BackupEngine] Job failed: {error_message}")
            retry_info = ""
            if job.get('retry_on_failure', 1) and Config.C.get("RETRY_ON_FAILURE", True):
                retry_count = int(job.get('retry_count', 0) or 0) + 1
                max_retries = int(Config.C.get("RETRY_MAX_ATTEMPTS", 3) or 3)
                if retry_count < max_retries:
                    retry_interval = int(Config.C.get('RETRY_INTERVAL_MINUTES', 60) or 60)
                    retry_info = f"\n\n Will retry in {retry_interval} minutes ({retry_count}/{max_retries})"
            
            # Notify failure if enabled
            if Config.C.get("DISCORD_NOTIFY_FAILURE", True):
                NotifyManager.discord_notify(
                    f" Backup Failed{retry_text}: {job_name}",
                    f"Error: {error_message or 'Unknown error'}{retry_info}",
                    "red"
                )
            NotifyManager.unraid_notify(f"Backup FAILED: {job_name}", error_message or "Unknown error", "alert")
        
        with cls._lock:
            cls.current_job = None
            cls.current_history_id = None
            cls.current_progress = {}
        
        logger.info("=" * 60)
        logger.info(f"[BackupEngine] Job finished: {job_name} - {status}")
        logger.info("=" * 60)
        
        return success, error_message
    
    @classmethod
    def _run_local(cls, job, dry_run):
        source = job.get('source_path', '')
        dest = job.get('dest_path', '')
        
        if not source:
            return False, 0, 0, "Source path not configured", ""
        if not dest:
            return False, 0, 0, "Destination path not configured", ""
        
        if not os.path.exists(source):
            return False, 0, 0, f"Source path does not exist: {source}", ""
        
        os.makedirs(dest, exist_ok=True)
        
        return cls._run_rsync(source, dest, job, dry_run)
    
    @classmethod
    def _run_remote_smb(cls, job, dry_run):
        source = job.get('source_path', '')
        remote_share = job.get('remote_share', '')
        mount_point = job.get('remote_mount_point', '')
        dest_subdir = job.get('dest_path', '')
        
        if not source:
            return False, 0, 0, "Source path not configured", ""
        if not remote_share:
            return False, 0, 0, "Remote share not configured", ""
        if not mount_point:
            return False, 0, 0, "Mount point not configured", ""
        
        if not MountManager.is_ud_available():
            return False, 0, 0, "Unassigned Devices plugin not installed", ""
        
        if not os.path.exists(source):
            return False, 0, 0, f"Source path does not exist: {source}", ""
        
        was_mounted = MountManager.is_mounted(mount_point)
        
        if not was_mounted:
            cls.current_progress['phase'] = 'mounting'
            success, msg = MountManager.mount(remote_share)
            if not success:
                return False, 0, 0, f"Failed to mount remote share: {msg}", ""
            
            time.sleep(Config.C.get('SMB_SETTLE_TIME', 10))
            
            if not MountManager.is_mounted(mount_point):
                return False, 0, 0, "Mount point not available after mount command", ""
        
        dest = os.path.join(mount_point, dest_subdir) if dest_subdir else mount_point
        os.makedirs(dest, exist_ok=True)
        
        cls.current_progress['phase'] = 'transferring'
        
        try:
            return cls._run_rsync(source, dest, job, dry_run)
        finally:
            if not was_mounted:
                cls.current_progress['phase'] = 'unmounting'
                MountManager.unmount(remote_share)
    
    @classmethod
    def _run_remote_smb_wol(cls, job, dry_run):
        host = job.get('remote_host', '')
        mac = job.get('mac_address', '')
        
        if not host:
            return False, 0, 0, "Remote host not configured", ""
        
        cls.current_progress['phase'] = 'checking host'
        host_was_online = WakeOnLan.ping(host)
        logger.info(f"[BackupEngine] Host {host} online: {host_was_online}")
        
        if not host_was_online:
            if not mac:
                return False, 0, 0, "Host offline and no MAC address configured for WOL", ""
            
            cls.current_progress['phase'] = 'sending WOL'
            success, msg = WakeOnLan.send_magic_packet(mac)
            if not success:
                return False, 0, 0, f"Failed to send WOL packet: {msg}", ""
            
            cls.current_progress['phase'] = 'waiting for host'
            timeout = Config.C.get("WOL_WAIT_TIMEOUT", 120)
            interval = Config.C.get("WOL_PING_INTERVAL", 5)
            online, elapsed = WakeOnLan.wait_for_host(host, timeout, interval)
            
            if not online:
                return False, 0, 0, f"Host did not come online within {timeout}s", ""
            
            smb_wait = Config.C.get("SMB_SETTLE_TIME", 10)
            logger.info(f"[BackupEngine] Waiting {smb_wait}s for SMB service...")
            time.sleep(smb_wait)
        
        success, bytes_transferred, files_transferred, error, log_output = cls._run_remote_smb(job, dry_run)
        
        if success and job.get('shutdown_after') and not host_was_online:
            user = job.get('remote_user', '')
            password = job.get('remote_pass', '')
            
            if user and password:
                cls.current_progress['phase'] = 'shutting down remote'
                logger.info(f"[BackupEngine] Sending shutdown to {host}")
                shutdown_ok, shutdown_msg = RemoteShutdown.shutdown_windows(host, user, password)
                if not shutdown_ok:
                    logger.warning(f"[BackupEngine] Shutdown failed: {shutdown_msg}")
            else:
                logger.info("[BackupEngine] Skipping shutdown - credentials not configured")
        
        return success, bytes_transferred, files_transferred, error, log_output
    
    @classmethod
    def _run_rsync(cls, source, dest, job, dry_run):
        cmd = ['rsync']
        
        options = Config.C.get("RSYNC_OPTIONS", "-avh --delete --stats")
        cmd.extend(options.split())
        
        bw_limit = int(job.get('bandwidth_limit', 0) or 0) or int(Config.C.get("DEFAULT_BANDWIDTH_LIMIT", 0) or 0)
        if bw_limit > 0:
            cmd.append(f'--bwlimit={bw_limit}')
        
        excludes = job.get('exclude_patterns', '') or ''
        for pattern in excludes.split('\n'):
            pattern = pattern.strip()
            if pattern and not pattern.startswith('#'):
                cmd.append(f'--exclude={pattern}')
        
        if dry_run:
            cmd.append('--dry-run')
        
        source = source.rstrip('/') + '/'
        cmd.extend([source, dest])
        
        logger.info(f"[BackupEngine] Rsync command: {' '.join(cmd)}")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=86400)
            
            output = result.stdout + '\n' + result.stderr
            
            bytes_transferred = 0
            files_transferred = 0
            
            for line in output.split('\n'):
                line_lower = line.lower()
                
                # Try multiple patterns for bytes transferred
                if 'total transferred file size:' in line_lower:
                    match = re.search(r'([\d,\.]+)\s*bytes', line, re.IGNORECASE)
                    if match:
                        try:
                            bytes_transferred = int(match.group(1).replace(',', '').replace('.', ''))
                        except:
                            pass
                elif 'literal data:' in line_lower and bytes_transferred == 0:
                    # Fallback to "Literal data" which shows actual bytes sent
                    match = re.search(r'([\d,\.]+)\s*bytes', line, re.IGNORECASE)
                    if match:
                        try:
                            bytes_transferred = int(match.group(1).replace(',', '').replace('.', ''))
                        except:
                            pass
                elif 'total bytes sent:' in line_lower and bytes_transferred == 0:
                    # Another fallback
                    match = re.search(r'([\d,\.]+)', line.split(':')[1])
                    if match:
                        try:
                            bytes_transferred = int(match.group(1).replace(',', '').replace('.', ''))
                        except:
                            pass
                            
                # Files transferred
                if 'number of regular files transferred:' in line_lower:
                    match = re.search(r'(\d+)', line.split(':')[1] if ':' in line else line)
                    if match:
                        try:
                            files_transferred = int(match.group(1))
                        except:
                            pass
                elif 'number of files transferred:' in line_lower and files_transferred == 0:
                    match = re.search(r'(\d+)', line.split(':')[1] if ':' in line else line)
                    if match:
                        try:
                            files_transferred = int(match.group(1))
                        except:
                            pass
            
            # Log parsed values for debugging
            logger.info(f"[BackupEngine] Parsed stats: {files_transferred} files, {bytes_transferred} bytes")
            
            if result.returncode == 0:
                return True, bytes_transferred, files_transferred, None, output
            else:
                if result.returncode in [23, 24]:
                    logger.warning(f"[BackupEngine] Rsync completed with warnings (exit {result.returncode})")
                    return True, bytes_transferred, files_transferred, f"Completed with warnings (exit {result.returncode})", output
                
                error = f"Rsync failed with exit code {result.returncode}"
                return False, bytes_transferred, files_transferred, error, output
                
        except subprocess.TimeoutExpired:
            return False, 0, 0, "Rsync timed out after 24 hours", ""
        except Exception as e:
            return False, 0, 0, str(e), ""

# ============================================
# SCHEDULER
# ============================================

class Scheduler:
    _thread = None
    _running = False
    _stopped = False
    _last_run = {}
    _summary_sent_today = False
    
    @classmethod
    def start(cls):
        if cls._thread and cls._thread.is_alive():
            logger.warning("[Scheduler] Already running")
            return
        
        cls._running = True
        cls._stopped = False
        cls._thread = threading.Thread(target=cls._run, daemon=True, name="Scheduler")
        cls._thread.start()
        logger.info("[Scheduler] Started")
    
    @classmethod
    def stop(cls):
        if cls._stopped:
            return  # Prevent re-entry
        cls._stopped = True
        cls._running = False
        if cls._thread:
            cls._thread.join(timeout=5)
        logger.info("[Scheduler] Stopped")
    
    @classmethod
    def _run(cls):
        while cls._running:
            try:
                now = datetime.now()
                cls._check_daily_summary(now)
                cls._check_jobs(now)
                cls._check_retries()
            except Exception as e:
                logger.error(f"[Scheduler] Error in main loop: {e}")
            
            time.sleep(60)
    
    @classmethod
    def _check_daily_summary(cls, now):
        summary_hour = Config.C.get("DISCORD_SUMMARY_HOUR", 20)
        
        if now.hour == summary_hour and now.minute == 0:
            if not cls._summary_sent_today:
                NotifyManager.send_daily_summary()
                cls._summary_sent_today = True
        elif now.hour != summary_hour:
            cls._summary_sent_today = False
    
    @classmethod
    def _check_jobs(cls, now):
        if BackupEngine.is_running():
            return
        
        jobs = DB.get_enabled_jobs()
        
        for job in jobs:
            job_id = job['id']
            schedule_type = job.get('schedule_type', 'disabled')
            
            if schedule_type == 'disabled':
                continue
            
            if cls._should_run(job, now):
                last = cls._last_run.get(job_id)
                if last and (now - last).total_seconds() < 60:
                    continue
                
                cls._last_run[job_id] = now
                logger.info(f"[Scheduler] Starting scheduled job: {job['name']}")
                
                thread = threading.Thread(
                    target=BackupEngine.run_job,
                    args=(job, False, False),
                    name=f"Backup-{job['name']}"
                )
                thread.start()
                break
    
    @classmethod
    def _check_retries(cls):
        """Check for failed jobs that need retry"""
        if not Config.C.get("RETRY_ON_FAILURE", True):
            return
        
        if BackupEngine.is_running():
            return
        
        try:
            jobs = DB.get_failed_jobs_for_retry()
            
            for job in jobs:
                logger.info(f"[Scheduler] Retrying failed job: {job['name']} (attempt {job.get('retry_count', 0) + 1})")
                
                thread = threading.Thread(
                    target=BackupEngine.run_job,
                    args=(job, False, True),
                    name=f"Retry-{job['name']}"
                )
                thread.start()
                break
        except Exception as e:
            logger.error(f"[Scheduler] Error checking retries: {e}")
    
    @classmethod
    def _should_run(cls, job, now):
        schedule_type = job.get('schedule_type', 'disabled')
        hour = job.get('schedule_hour', 0)
        minute = job.get('schedule_minute', 0)
        day = job.get('schedule_day', 0)
        
        if schedule_type == 'hourly':
            return now.minute == minute
        elif schedule_type == 'daily':
            return now.hour == hour and now.minute == minute
        elif schedule_type == 'weekly':
            return now.weekday() == day and now.hour == hour and now.minute == minute
        elif schedule_type == 'custom':
            cron = job.get('schedule_cron', '')
            return cls._match_cron(cron, now)
        
        return False
    
    @classmethod
    def _match_cron(cls, cron_expr, dt):
        if not cron_expr:
            return False
        
        try:
            parts = cron_expr.split()
            if len(parts) != 5:
                return False
            
            minute, hour, day, month, weekday = parts
            
            checks = [
                (minute, dt.minute),
                (hour, dt.hour),
                (day, dt.day),
                (month, dt.month),
                (weekday, dt.weekday())
            ]
            
            for pattern, value in checks:
                if not cls._cron_match(pattern, value):
                    return False
            
            return True
        except:
            return False
    
    @classmethod
    def _cron_match(cls, pattern, value):
        if pattern == '*':
            return True
        
        if pattern.startswith('*/'):
            try:
                step = int(pattern[2:])
                return value % step == 0
            except:
                return False
        
        if ',' in pattern:
            values = [int(v) for v in pattern.split(',')]
            return value in values
        
        if '-' in pattern:
            try:
                start, end = pattern.split('-')
                return int(start) <= value <= int(end)
            except:
                return False
        
        try:
            return value == int(pattern)
        except:
            return False

# ============================================
# HTTP API SERVER
# ============================================

class APIHandler(BaseHTTPRequestHandler):
    def log_message(self, format, *args):
        logger.debug(f"[API] {args[0]}")
    
    def _send_json(self, data, status=200):
        self.send_response(status)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()
        self.wfile.write(json.dumps(data, default=str).encode())
    
    def _read_json(self):
        content_length = int(self.headers.get('Content-Length', 0))
        if content_length > 0:
            body = self.rfile.read(content_length)
            return json.loads(body.decode())
        return {}
    
    def do_OPTIONS(self):
        self._send_json({'success': True})
    
    def do_GET(self):
        parsed = urlparse(self.path)
        path = parsed.path
        params = parse_qs(parsed.query)
        
        try:
            if path == '/api/status':
                uptime = int(time.time() - START_TIME)
                status = BackupEngine.get_status()
                self._send_json({
                    'success': True,
                    'version': Config.VERSION,
                    'uptime': uptime,
                    'ud_available': MountManager.is_ud_available(),
                    'backup': status
                })
            
            elif path == '/api/jobs':
                jobs = DB.get_jobs()
                for job in jobs:
                    last = DB.get_last_run(job['id'])
                    job['last_run'] = last
                self._send_json({'success': True, 'jobs': jobs})
            
            elif path.startswith('/api/jobs/') and path.count('/') == 3:
                job_id = int(path.split('/')[-1])
                job = DB.get_job(job_id)
                if job:
                    job['last_run'] = DB.get_last_run(job_id)
                    self._send_json({'success': True, 'job': job})
                else:
                    self._send_json({'success': False, 'error': 'Job not found'}, 404)
            
            elif path == '/api/history':
                limit = int(params.get('limit', [100])[0])
                job_id = params.get('job_id', [None])[0]
                if job_id:
                    job_id = int(job_id)
                history = DB.get_history(limit, job_id)
                self._send_json({'success': True, 'history': history})
            
            elif path == '/api/stats':
                days = int(params.get('days', [30])[0])
                stats = DB.get_stats(days)
                totals = DB.get_totals()
                self._send_json({'success': True, 'stats': stats, 'totals': totals})
            
            elif path == '/api/logs':
                lines = int(params.get('lines', [200])[0])
                if os.path.exists(LOG_FILE):
                    with open(LOG_FILE, 'r') as f:
                        all_lines = f.readlines()
                        log_content = ''.join(all_lines[-lines:])
                else:
                    log_content = "No log file found"
                self._send_json({'success': True, 'logs': log_content})
            
            elif path == '/api/settings':
                self._send_json({'success': True, 'settings': Config.C})
            
            else:
                self._send_json({'success': False, 'error': 'Not found'}, 404)
                
        except Exception as e:
            logger.error(f"[API] GET error: {e}")
            self._send_json({'success': False, 'error': str(e)}, 500)
    
    def do_POST(self):
        path = self.path
        
        try:
            data = self._read_json()
            
            if path == '/api/jobs':
                job_id = DB.create_job(data)
                self._send_json({'success': True, 'id': job_id})
            
            elif path.startswith('/api/jobs/') and path.endswith('/run'):
                job_id = int(path.split('/')[-2])
                job = DB.get_job(job_id)
                if job:
                    dry_run = data.get('dry_run', False)
                    
                    if BackupEngine.is_running():
                        self._send_json({'success': False, 'error': 'Another backup is running'}, 409)
                    else:
                        thread = threading.Thread(
                            target=BackupEngine.run_job,
                            args=(job, dry_run, False),
                            name=f"Backup-{job['name']}"
                        )
                        thread.start()
                        self._send_json({'success': True, 'message': 'Job started'})
                else:
                    self._send_json({'success': False, 'error': 'Job not found'}, 404)
            
            elif path.startswith('/api/jobs/') and path.endswith('/toggle'):
                job_id = int(path.split('/')[-2])
                enabled = int(data.get('enabled', 0))
                DB.toggle_job(job_id, enabled)
                self._send_json({'success': True, 'enabled': enabled})
            
            elif path == '/api/abort':
                BackupEngine.abort()
                self._send_json({'success': True, 'message': 'Abort requested'})
            
            elif path == '/api/settings':
                Config.C.update(data)
                success, msg = Config.save()
                self._send_json({'success': success, 'message': msg})
            
            elif path == '/api/test/wol':
                mac = data.get('mac_address')
                if mac:
                    success, msg = WakeOnLan.send_magic_packet(mac)
                    self._send_json({'success': success, 'message': msg})
                else:
                    self._send_json({'success': False, 'error': 'MAC address required'})
            
            elif path == '/api/test/ping':
                host = data.get('host')
                if host:
                    reachable = WakeOnLan.ping(host)
                    self._send_json({'success': True, 'reachable': reachable})
                else:
                    self._send_json({'success': False, 'error': 'Host required'})
            
            elif path == '/api/test/discord':
                url = Config.C.get("DISCORD_WEBHOOK_URL", "")
                if not url:
                    self._send_json({'success': False, 'error': 'Discord webhook URL not configured'})
                else:
                    success = NotifyManager.discord_notify(
                        " Test Notification",
                        "This is a test message from ATP Backup",
                        "blue"
                    )
                    self._send_json({'success': success, 'message': 'Test sent' if success else 'Failed to send'})
            
            elif path == '/api/test/mount':
                share = data.get('share')
                if share:
                    success, msg = MountManager.mount(share)
                    if success:
                        time.sleep(2)
                        MountManager.unmount(share)
                    self._send_json({'success': success, 'message': msg})
                else:
                    self._send_json({'success': False, 'error': 'Share required'})
            
            # Database management endpoints
            elif path == '/api/database/clear_history':
                DB.clear_history()
                self._send_json({'success': True, 'message': 'History cleared'})
            
            elif path == '/api/database/reset_statistics':
                DB.reset_statistics()
                self._send_json({'success': True, 'message': 'Statistics reset'})
            
            elif path == '/api/database/reset':
                DB.reset_database()
                self._send_json({'success': True, 'message': 'Database reset complete'})
            
            else:
                self._send_json({'success': False, 'error': 'Not found'}, 404)
                
        except Exception as e:
            logger.error(f"[API] POST error: {e}")
            self._send_json({'success': False, 'error': str(e)}, 500)
    
    def do_PUT(self):
        path = self.path
        
        try:
            data = self._read_json()
            
            if path.startswith('/api/jobs/'):
                job_id = int(path.split('/')[-1])
                job = DB.get_job(job_id)
                if job:
                    updated = {**job, **data}
                    DB.update_job(job_id, updated)
                    self._send_json({'success': True})
                else:
                    self._send_json({'success': False, 'error': 'Job not found'}, 404)
            else:
                self._send_json({'success': False, 'error': 'Not found'}, 404)
                
        except Exception as e:
            logger.error(f"[API] PUT error: {e}")
            self._send_json({'success': False, 'error': str(e)}, 500)
    
    def do_DELETE(self):
        path = self.path
        
        try:
            if path.startswith('/api/jobs/'):
                job_id = int(path.split('/')[-1])
                DB.delete_job(job_id)
                self._send_json({'success': True})
            else:
                self._send_json({'success': False, 'error': 'Not found'}, 404)
                
        except Exception as e:
            logger.error(f"[API] DELETE error: {e}")
            self._send_json({'success': False, 'error': str(e)}, 500)

# ============================================
# MAIN
# ============================================

server = None
shutting_down = False

def signal_handler(signum, frame):
    global shutting_down
    if shutting_down:
        return  # Prevent re-entry
    shutting_down = True
    logger.info(f"[Main] Received signal {signum}, shutting down...")
    Scheduler.stop()
    if server:
        threading.Thread(target=server.shutdown).start()

def main():
    global server
    
    logger.info("=" * 60)
    logger.info(f"ATP Backup v{Config.VERSION} starting...")
    logger.info(f"Log level: {Config.C.get('LOG_LEVEL', 'INFO')}")
    logger.info(f"Data directory: {Config.DATA_DIR}")
    logger.info(f"Config directory: {Config.CONFIG_DIR}")
    logger.info(f"API port: {Config.C['SERVER_PORT']}")
    logger.info(f"Unassigned Devices: {'Available' if MountManager.is_ud_available() else 'Not found'}")
    logger.info(f"Retry on failure: {Config.C.get('RETRY_ON_FAILURE', True)}")
    logger.info("=" * 60)
    
    try:
        with open(Config.PID_FILE, 'w') as f:
            f.write(str(os.getpid()))
    except Exception as e:
        logger.warning(f"[Main] Could not write PID file: {e}")
    
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    Scheduler.start()
    
    port = Config.C['SERVER_PORT']
    try:
        server = ThreadingHTTPServer(('0.0.0.0', port), APIHandler)
        logger.info(f"[Main] API server listening on port {port}")
        server.serve_forever()
    except OSError as e:
        if e.errno == 98:
            logger.error(f"[Main] Port {port} already in use!")
        else:
            raise
    except KeyboardInterrupt:
        pass
    finally:
        Scheduler.stop()
        if os.path.exists(Config.PID_FILE):
            try:
                os.remove(Config.PID_FILE)
            except:
                pass
        logger.info("[Main] ATP Backup stopped")

if __name__ == "__main__":
    main()

]]>
</INLINE>
</FILE>

<!-- RC Service Script -->
<FILE Name="/usr/local/emhttp/plugins/atp_backup/rc.atp_backup" Mode="0755">
<INLINE>
<![CDATA[
#!/bin/bash
# rc.atp_backup - Service control script for ATP Backup

PLUGIN_NAME="atp_backup"
DAEMON="/usr/local/emhttp/plugins/${PLUGIN_NAME}/${PLUGIN_NAME}.py"
PID_FILE="/var/run/${PLUGIN_NAME}.pid"
CONFIG_DIR="/boot/config/plugins/${PLUGIN_NAME}"
DATA_DIR="/mnt/user/appdata/${PLUGIN_NAME}"

# Ensure directories exist
mkdir -p "${DATA_DIR}/logs"
mkdir -p "${CONFIG_DIR}"

start() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "${PLUGIN_NAME} is already running (PID $PID)"
            return 1
        else
            rm -f "$PID_FILE"
        fi
    fi
    
    echo "Starting ${PLUGIN_NAME}..."
    chmod +x "$DAEMON"
    
    # Start daemon - Python handles its own logging, redirect nohup output to /dev/null
    nohup python3 "$DAEMON" >/dev/null 2>&1 &
    echo $! > "$PID_FILE"
    
    # Wait for service to be ready
    sleep 2
    
    if [ -f "$PID_FILE" ] && kill -0 "$(cat $PID_FILE)" 2>/dev/null; then
        echo "${PLUGIN_NAME} started (PID $(cat $PID_FILE))"
        return 0
    else
        echo "Failed to start ${PLUGIN_NAME}"
        rm -f "$PID_FILE"
        return 1
    fi
}

stop() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        echo "Stopping ${PLUGIN_NAME} (PID $PID)..."
        kill "$PID" 2>/dev/null
        
        for i in {1..10}; do
            if ! kill -0 "$PID" 2>/dev/null; then
                break
            fi
            sleep 1
        done
        
        if kill -0 "$PID" 2>/dev/null; then
            echo "Force killing ${PLUGIN_NAME}..."
            kill -9 "$PID" 2>/dev/null
        fi
        
        rm -f "$PID_FILE"
        echo "${PLUGIN_NAME} stopped"
    else
        echo "${PLUGIN_NAME} is not running"
    fi
    
    # Also kill any orphaned processes
    pkill -f "${PLUGIN_NAME}.py" 2>/dev/null || true
}

restart() {
    stop
    sleep 2
    start
}

status() {
    if [ -f "$PID_FILE" ]; then
        PID=$(cat "$PID_FILE")
        if kill -0 "$PID" 2>/dev/null; then
            echo "${PLUGIN_NAME} is running (PID $PID)"
            return 0
        else
            echo "${PLUGIN_NAME} is not running (stale PID file)"
            rm -f "$PID_FILE"
            return 1
        fi
    else
        echo "${PLUGIN_NAME} is not running"
        return 1
    fi
}

case "$1" in
    start) start ;;
    stop) stop ;;
    restart) restart ;;
    status) status ;;
    *) echo "Usage: $0 {start|stop|restart|status}"; exit 1 ;;
esac

]]>
</INLINE>
</FILE>

<!-- AJAX Handler -->
<FILE Name="/usr/local/emhttp/plugins/atp_backup/include/ajax.php">
<INLINE>
<![CDATA[
<?php
/**
 * ATP Backup - AJAX Handler v2026.01.30
 * Proxies requests to Python daemon API
 *
 * SECURITY: CSRF validation for Unraid 7.x
 */

// Read port from settings
$CONFIG_FILE = "/boot/config/plugins/atp_backup/settings.json";
$API_PORT = 39982; // Default port
$API_HOST = "127.0.0.1";

if (file_exists($CONFIG_FILE)) {
    $config = json_decode(file_get_contents($CONFIG_FILE), true);
    if (isset($config['SERVER_PORT'])) {
        $API_PORT = intval($config['SERVER_PORT']);
    }
}

// ============================================
// CSRF VALIDATION (Unraid 7.x Security)
// ============================================
// Actions that modify state require CSRF validation
$modifying_actions = [
    'create_job', 'update_job', 'toggle_job', 'delete_job', 'run_job',
    'save_settings', 'service', 'abort',
    'clear_history', 'reset_statistics', 'reset_database'
];

$action = $_REQUEST['action'] ?? '';

// Validate CSRF token for modifying operations
if (in_array($action, $modifying_actions)) {
    $csrf_token = $_POST['csrf_token'] ?? $_GET['csrf_token'] ?? $_REQUEST['csrf_token'] ?? '';
    $valid_csrf = false;

    // Read Unraid's CSRF token from var.ini
    $var_file = '/var/local/emhttp/var.ini';
    if (file_exists($var_file)) {
        $var = @parse_ini_file($var_file);
        if ($var && isset($var['csrf_token'])) {
            $valid_csrf = hash_equals($var['csrf_token'], $csrf_token);
        }
    }

    if (!$valid_csrf) {
        header('Content-Type: application/json');
        echo json_encode(['success' => false, 'error' => 'Invalid or missing CSRF token']);
        exit;
    }
}

// Helper function to make API requests
function apiCall($endpoint, $method = 'GET', $data = null) {
    global $API_PORT, $API_HOST;

    $url = "http://{$API_HOST}:{$API_PORT}{$endpoint}";

    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($ch, CURLOPT_TIMEOUT, 30);
    curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 5);

    if ($method === 'POST') {
        curl_setopt($ch, CURLOPT_POST, true);
        if ($data) {
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));
            curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
        }
    } elseif ($method === 'PUT') {
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'PUT');
        if ($data) {
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data));
            curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
        }
    } elseif ($method === 'DELETE') {
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, 'DELETE');
    }

    $response = curl_exec($ch);
    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    $curlError = curl_error($ch);
    curl_close($ch);

    if ($curlError) {
        return ['success' => false, 'error' => "API unavailable: {$curlError}"];
    }

    if (empty($response)) {
        return ['success' => false, 'error' => 'Empty response from API'];
    }

    $decoded = json_decode($response, true);
    if ($decoded === null) {
        return ['success' => false, 'error' => 'Invalid API response: ' . substr($response, 0, 100)];
    }

    return $decoded;
}

// Get POST data - handles both JSON and form-urlencoded
function getPostData() {
    $contentType = $_SERVER['CONTENT_TYPE'] ?? '';

    if (strpos($contentType, 'application/json') !== false) {
        return json_decode(file_get_contents('php://input'), true) ?: [];
    }

    // Form-urlencoded data (from URLSearchParams)
    $data = $_POST;

    // Remove csrf_token from data sent to API
    unset($data['csrf_token']);

    // Convert string booleans
    foreach ($data as $key => $value) {
        if ($value === 'true') $data[$key] = true;
        if ($value === 'false') $data[$key] = false;
    }

    return $data;
}

header('Content-Type: application/json');

switch ($action) {

    case 'status':
        echo json_encode(apiCall('/api/status'));
        break;
    
    case 'get_jobs':
        echo json_encode(apiCall('/api/jobs'));
        break;
    
    case 'get_job':
        $id = intval($_REQUEST['id'] ?? 0);
        echo json_encode(apiCall("/api/jobs/{$id}"));
        break;
    
    case 'create_job':
        $data = getPostData();
        echo json_encode(apiCall('/api/jobs', 'POST', $data));
        break;
    
    case 'update_job':
        $id = intval($_REQUEST['id'] ?? 0);
        $data = getPostData();
        unset($data['id']); // Remove id from data, it's in URL
        echo json_encode(apiCall("/api/jobs/{$id}", 'PUT', $data));
        break;
    
    case 'toggle_job':
        $id = intval($_REQUEST['id'] ?? 0);
        $enabled = intval($_REQUEST['enabled'] ?? 0);
        echo json_encode(apiCall("/api/jobs/{$id}/toggle", 'POST', ['enabled' => $enabled]));
        break;
    
    case 'delete_job':
        $id = intval($_REQUEST['id'] ?? 0);
        echo json_encode(apiCall("/api/jobs/{$id}", 'DELETE'));
        break;
    
    case 'run_job':
        $id = intval($_REQUEST['id'] ?? 0);
        $dryRun = ($_REQUEST['dry_run'] ?? 'false') === 'true';
        echo json_encode(apiCall("/api/jobs/{$id}/run", 'POST', ['dry_run' => $dryRun]));
        break;
    
    case 'get_history':
        $limit = intval($_REQUEST['limit'] ?? 100);
        $jobId = $_REQUEST['job_id'] ?? '';
        $query = "?limit={$limit}";
        if ($jobId) $query .= "&job_id={$jobId}";
        echo json_encode(apiCall("/api/history{$query}"));
        break;
    
    case 'get_stats':
        $days = intval($_REQUEST['days'] ?? 30);
        echo json_encode(apiCall("/api/stats?days={$days}"));
        break;
    
    case 'get_logs':
        $lines = intval($_REQUEST['lines'] ?? 200);
        $result = apiCall("/api/logs?lines={$lines}");
        
        // Fallback: read log file directly if API fails
        if (!$result['success']) {
            $logFile = '/mnt/user/appdata/atp_backup/logs/atp_backup.log';
            if (file_exists($logFile)) {
                $logLines = file($logFile);
                $logLines = array_slice($logLines, -$lines);
                $result = ['success' => true, 'logs' => implode("", $logLines)];
            }
        }
        echo json_encode($result);
        break;
    
    case 'get_settings':
        echo json_encode(apiCall('/api/settings'));
        break;
    
    case 'save_settings':
        $data = getPostData();
        echo json_encode(apiCall('/api/settings', 'POST', $data));
        break;
    
    case 'test_wol':
        $mac = $_REQUEST['mac_address'] ?? '';
        echo json_encode(apiCall('/api/test/wol', 'POST', ['mac_address' => $mac]));
        break;
    
    case 'test_ping':
        $host = $_REQUEST['host'] ?? '';
        echo json_encode(apiCall('/api/test/ping', 'POST', ['host' => $host]));
        break;
    
    case 'test_discord':
        echo json_encode(apiCall('/api/test/discord', 'POST'));
        break;
    
    case 'test_mount':
        $share = $_REQUEST['share'] ?? '';
        echo json_encode(apiCall('/api/test/mount', 'POST', ['share' => $share]));
        break;
    
    case 'service':
        $cmd = $_REQUEST['cmd'] ?? '';
        $validCmds = ['start', 'stop', 'restart', 'status'];
        
        if (!in_array($cmd, $validCmds)) {
            echo json_encode(['success' => false, 'error' => 'Invalid command']);
            break;
        }
        
        $script = '/usr/local/emhttp/plugins/atp_backup/rc.atp_backup';
        exec("{$script} {$cmd} 2>&1", $output, $returnCode);
        
        echo json_encode([
            'success' => $returnCode === 0,
            'output' => implode("\n", $output),
            'code' => $returnCode
        ]);
        break;
    
    case 'abort':
        echo json_encode(apiCall('/api/abort', 'POST'));
        break;
    
    case 'clear_history':
        echo json_encode(apiCall('/api/database/clear_history', 'POST'));
        break;
    
    case 'reset_statistics':
        echo json_encode(apiCall('/api/database/reset_statistics', 'POST'));
        break;
    
    case 'reset_database':
        echo json_encode(apiCall('/api/database/reset', 'POST'));
        break;
    
    default:
        echo json_encode(['success' => false, 'error' => 'Unknown action']);
        break;
}

]]>
</INLINE>
</FILE>

<!-- Post-install: Set up directories and auto-start -->
<FILE Run="/bin/bash">
<INLINE>
<![CDATA[
#!/bin/bash
PLUGIN_NAME="atp_backup"
DATA_DIR="/mnt/user/appdata/${PLUGIN_NAME}"
CONFIG_DIR="/boot/config/plugins/${PLUGIN_NAME}"
RC_SCRIPT="/usr/local/emhttp/plugins/${PLUGIN_NAME}/rc.${PLUGIN_NAME}"
GO_FILE="/boot/config/go"
LOG="/var/log/${PLUGIN_NAME}_install.log"

echo "$(date): Post-install starting" >> "$LOG"

# Create directories
mkdir -p "$DATA_DIR/logs"
mkdir -p "$CONFIG_DIR"

# Make scripts executable
chmod +x "/usr/local/emhttp/plugins/${PLUGIN_NAME}/${PLUGIN_NAME}.py"
chmod +x "$RC_SCRIPT"

# Add to startup if not already there
if ! grep -q "rc.${PLUGIN_NAME}" "$GO_FILE" 2>/dev/null; then
    echo "" >> "$GO_FILE"
    echo "# Start ATP Backup" >> "$GO_FILE"
    echo "$RC_SCRIPT start &" >> "$GO_FILE"
    echo "$(date): Added to $GO_FILE" >> "$LOG"
fi

# Start the service in background with delay
(
    sleep 5
    "$RC_SCRIPT" start >> "$LOG" 2>&1
) &

echo "$(date): Post-install complete" >> "$LOG"
echo ""
echo "ATP Backup v2026.01.30g installed!"
echo "Service will start in 5 seconds..."
]]>
</INLINE>
</FILE>

<!-- Uninstall script -->
<FILE Run="/bin/bash" Method="remove">
<INLINE>
<![CDATA[
#!/bin/bash
PLUGIN_NAME="atp_backup"
RC_SCRIPT="/usr/local/emhttp/plugins/${PLUGIN_NAME}/rc.${PLUGIN_NAME}"
GO_FILE="/boot/config/go"

echo "Removing ATP Backup..."

# Stop service
if [ -f "$RC_SCRIPT" ]; then
    "$RC_SCRIPT" stop 2>/dev/null
fi
pkill -f "${PLUGIN_NAME}.py" 2>/dev/null || true
rm -f "/var/run/${PLUGIN_NAME}.pid"

# Remove from startup
if [ -f "$GO_FILE" ]; then
    sed -i "/# Start ATP Backup/d" "$GO_FILE"
    sed -i "/rc.${PLUGIN_NAME}/d" "$GO_FILE"
fi

# Remove plugin files (keep config and data)
rm -rf "/usr/local/emhttp/plugins/${PLUGIN_NAME}"
rm -f "/var/log/${PLUGIN_NAME}_install.log"
rm -f "/var/log/${PLUGIN_NAME}_startup.log"

echo "ATP Backup removed."
echo "Config preserved at: /boot/config/plugins/${PLUGIN_NAME}"
echo "Data preserved at: /mnt/user/appdata/${PLUGIN_NAME}"
]]>
</INLINE>
</FILE>

</PLUGIN>
